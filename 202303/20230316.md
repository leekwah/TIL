##### DB


- 넓은 의미에서의 데이터베이스는 이러한 일상적인 정보들을 모아 놓은 것 자체를 의미한다. 그러나 일반적으로 데이터베이스라고 말할 때는 특정 기업이나 조직 또는 개인이 필요에 의해(ex: 부가가치가 발생하는) 데이터를 일정한 형태로 저장해 놓은 것을 의미한다.

##### DBMS(Database Management System)

- 보다 효율적인 데이터의 관리 뿐만 아니라 예기치 못한 사건으로 인한 데이터의 손상을 피하고, 필요시 필요한 데이터를 복구하기 위한 강력한 기능의 소프트웨어를 필요로 하게 되었고 이러한 기본적인 요구사항을 만족시켜주는 시스템을 DBMS(Database Management System)라고 한다.

##### 관계형 데이터 베이스의 기능

- 정규화를 통한 합리적인 테이블 모델링을 통해 이상(ANOMALY) 현상을 제거할 수 있다.
- 데이터 중복을 피할 수 있다.
- 동시성 관리가 가능하다.
- 병행 제어를 통해 많은 사용자들이 동시에 데이터를 공유 및 조작할 수 있는 기능을 제공한다.
- 메타 데이터를 총괄 관리할 수 있기 때문에 데이터의 성격, 속성 또는 표현 방법 등을 체계화할 수 있다.
- 데이터 표준화를 통한 데이터 품질을 확보할 수 있다.
- 인증된 사용자만이 참조할 수 있도록 보안 기능을 제공한다.
- 데이터 무결성(Integrity)을 보장할 수 있다.
- 시스템의 갑작스런 장애로부터 사용자가 입력, 수정, 삭제하던 데이터가 제대로 반영될 수 있도록 보장해주는 기능을 제공한다.
- 시스템 다운, 재해 등의 상황에서도 데이터를 회복/복구할 수 있는 기능을 제공한다.

##### SQL(Structured Query Language)

- SQL은 관계형 데이터베이스에서 데이터 정의(DDL), 데이터 조작(DML), 데이터 제어(DCL)를 하기 위해 사용하는 언어이다.

##### SQL 문장들의 종류

- 데이터 조작어(DML : Data Manipulation Language)
  - SELECT
  - INSERT
  - UPDATE
  - DELETE
- 데이터 정의어(DDL : Data Definition Language)
  - CREATE
  - ALTER
  - DROP
  - RENAME
- 데이터 제어어(DCL : Data Control Language)
  - GRANT
  - REVOKE
- 트랜잭션 제어어(TCL : Transaction Control Language)
  - COMMIT
  - ROLLBACK

##### 테이블

- 테이블은 어느 특정한 주제와 목적으로 만들어지는 일종의 집합이다.
- 테이블에는 등록된 자료들이 있으며, 이 자료들은 삭제하지 않는 한 지속적으로 유지된다. 만약 우리가 자료를 입력하지 않는다면 테이블은 본래 만들어졌을 때부터 가지고 있던 속성을 그대로 유지하면서 존재하게 된다.

##### 테이블의 구조

- 테이블(Table)은 데이터를 저장하는 객체(Object)로서 관계형 데이터베이스의 기본 단위이다.
- 칼럼/열(Column) : 테이블의 세로방향을 지칭한다.
- 행(Row) : 테이블의 가로 방향을 지칭한다.
- 필드(Field) : 칼럼과 행이 겹치는 하나의 공간을 지칭한다.

##### 테이블 용어

| 용어            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 테이블(Table)   | 행과 열의 2차원 구조를 가진 데이터의 저장 장소이며, 데이터베이스의 가장 기본적인 개념 |
| 칼럼/열(Column) | 2차원 구조를 가진 테이블에서 세로 방향으로 이루어진 하나하나의 특정 속성(더 이상 나눌 수 없는 특성) |
| 행(Row)         | 2차원 구조를 가진 테이블에서 가로 방향으로 이루어진 연결된 데이터 |

##### 정규화(Normalization)

- 테이블을 분할하여 데이터의 불필요한 중복을 줄이는 것이다.

##### 정규화의 목적

- 데이터의 정합성 확보한다.
- 데이터 입력/수정/삭제 시 발생할 수 있는 이상현상(Anomaly)을 방지한다.

##### 기본키(Primary Key)와 외부키(Foreign Key)

- 기본키(Primary Key) : 각 행을 한 가지 의미로 특정할 수 있는 한 개 이상의 칼럼을 의미한다.
- 외부키(Foreign Key) : 다른 테이블의 기본 키로 사용되면서, 테이블과의 관계를 연결하는 역할을 하는 칼럼을 의미한다.

##### 테이블 관계 용어들

| 용어                  | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| 정규화(Normalization) | 테이블을 분할하여 데이터의 정합성을 확보하고, 불필요한 중복을 줄이는 프로세스 |
| 기본키(Primary Key)   | 테이블에 존재하는 각 행을 한 가지 의미로 특정할 수 있는 한 개 이상의 칼럼 |
| 외부키(Foreign Key)   | 다른 테이블의 기본키로 사용되고 있는 관계를 연결하는 칼럼    |

##### ERD(Entity Relationship Diagram)

- 테이블 간 서로의 상관 관계를 그림으로 도식화한 것을 E-R 다이어그램이라고 하며, 간략히 ERD라고한다.
- IE(Information Engineering) 표기법과 Barker(Case Method) 표기법이 존재한다.

##### ERD의 구성 요소

- 엔터티(Entity), 관계(Relationship), 속성(Attribute)

##### IE 표기법

- 실선 : 식별관계
- 점선 : 비식별관계

##### Barker 표기법

- 수직바 : 식별관계

##### 데이터 유형

- 데이터 유형은 데이터베이스의 테이블에 특정 자료를 입력할 때, 그 자료를 받아들일 공간을 자료의 유형별로 나누는 기준이라고 생각하면 된다.
- 특정 칼럼을 정의할 때 선언한 데이터 유형은 그 칼럼이 받아들일 수 있는 자료의 유형을 규정한다. 따라서 선언한 유형이
  아닌 다른 종류의 데이터가 들어오려고 하면 데이터베이스는 에러를 발생시킨다.

##### 자주 쓰이는 데이터 유형

| 데이터 유형  | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| CHARACTER(s) | - 고정 길이 문자열 정보 (Oracle, SQL Server 모두 CHAR로 표현)<br />- s는 기본 길이 1바이트, 최대 길이 Oracle 2,000 bytes, SQL Server 8,000 bytes<br />- s만큼 최대 길이를 갖고 고정 길이를 가지고 있으므로 할당된 변수 값의 길이가 s보다 작을 경우에는 그 차이 길이만큼 공간으로 채워진다. |
| VARCHAR(s)   | - CHARACTER VARYING의 약자로 가변 길이 문자열 정보 (Oracle은 VARCHAR2로 표현, SQL Server는 VARCHAR로 표현)<br />- s는 최소 길이 1 byte, 최대 길이 Oracle 4,000 bytes, SQL Server 8,000 bytes<br />- s만큼 최대 길이를 갖지만 가변 길이로 조정이 되기 때문에 할당된 변수의 바이트만 적용된다. (Limit 개념) |
| NUMERIC      | - 정수, 실수 등 숫자 정보 (Oracle은 NUMBER로, SQL Server는 10가지 이상의 숫자 타입을 가지고 있음)<br />- Oracle은 처음에 전체자리 수를 지정하고, 그 다음 소수 부분의 자리 수를 지정한다. 예를 들어 'NUMBER(8, 2)'의 경우, 정수부분은 6자리, 소수점 부분은 2자리이다. |
| DATETIME     | - 날짜와 시각 정보 (Oracle은 DATE로 표현, SQL Server는 DATETIME으로 표현)<br />- Oracle은 1초 단위, SQL Server는 3.33 ms 단위 관리 |

##### CHAR 유형과 VARCHAR 유형의 차이점

- VARCHAR 유형은 가변 길이이므로 필요한 영역은 실제 데이터 크기 뿐이기 때문에, 길이가 다양한 칼럼과 정의된 길익와 실제 데이터 길이에 차이가 있는 데이터 칼럼에 적합하다.
- 저장 측면에서도 VARCHAR 유형이 CHAR 유형보다 작은 영역에 저장할 수 있는 장점이 있다.
- CHAR 유형은 공백(BLANK)를 저장하지 않기 때문에 'AA' = 'AA ' 로 같은 문자로 판단한다.
- 하지만, 가변 문자인 VARCHAR의 경우 'AA' ≠ 'AA ' 로 공백를 저장하기 때문에, 다른 문자로 판단한다.

##### CREATE TABLE

- 테이블은 일정한 형식에 의해서 생성된다. 테이블 생성을 위해서는 해당 테이블에 입력될 데이터를 정의하고, 정의한 데이터를 어떠한 유형으로 선언할 것이지를 결정해야 한다.

##### 테이블과 칼럼 정의

- 테이블에 존재하는 모든 데이터를 고유하게 식별할 수 있으면서 반드시 값이 존재하는 단일 칼럼이나 칼럼의 조합들(후보키) 중에 하나를 선정하여 기본키 칼럼으로 지정한다.
- 기본키는 단일 칼럼이 아닌 여러 개의 칼럼으로도 만들어질 수 있다. 그리고 테이블과 테이블 간에 정의된 관계는 기본키(PRIMARY KEY)와 외부키(FOREIGN KEY)를 활용해서 설정하도록 한다.

##### 테이블 생성 구문 형식

```sql
CREATE TABLE 테이블이름 (
    칼럼명1 DATATYPE [DEFAULT 형식],
    칼럼명2 DATATYPE [DEFAULT 형식],
    칼럼명3 DATATYPE [DEFAULT 형식]
);
```

##### 테이블 생성 시에 주의할 규칙

- 테이블명은 객체를 의미할 수 있는 적절한 이름을 사용해야하며, 가능한 단수형을 권고한다.
- 테이블 명은 다른 테이블의 이름과 중복되지 않아야 한다.
- 한 테이블 내에서는 칼럼이 중복되게 지정될 수 없다.
- 테이블 이름을 지정하고 각 칼럼들은 괄호"()"로 묶어 지정한다.
- 각 칼럼들은 콤마","로 구분되고, 테이블 생성문의 끝은 항상 세미콜론";"으로 끝난다.
- 데이터 표준화 관점에서 칼럼에 대해서는 다른 테이블까지 고려하여 데이터베이스 내에서는 일관성 있게 사용하는 것이 좋다.
- 칼럼 뒤에 데이터 유형은 꼭 지정되어야 한다.
- 테이블명과 칼럼명은 반드시 문자로 시작해야 하고, 벤더별로 길이에 대한 한계가 있다.
- 벤더에서 사전에 정의한 예악어(Reserved Word)는 쓸 수 없다.
- A-Z, a-z, 0-9, \_, \$, \# 문자만 허용된다.
- 한 테이블 안에서 칼럼이름은 달라야 하지만, 다른 테이블의 칼럼 이름과는 같을 수 있다. 같은 이름을 가진 칼럼들은 기본키와 외래키의 관계를 가지는 경우가 많으며, 향후 테이블 간의 조인 조건으로 주로 사용되는 중요한 연결고리 칼럼들이다.
- 테이블 생성시 대/소문자 구분은 하지 않는다. 기본적으로 테이블이나 칼럼명은 대문자로 만들어진다.
- DATETIME 데이터 유형에는 별도로 크기를 지정하지 않는다.
- 문자 데이터 유형은 반드시 가질 수 있는 최대 길이를 표시해야 한다.
- 칼럼과 칼럼의 구분은 콤마로 하되, 마지막 칼럼은 콤마를 찍지 않는다.
- 칼럼에 대한 제약조건이 있으면 CONSTRAINT를 이용하여 추가할 수 있다.

##### 제약조건(CONSTRAINT)

- 제약조건이란 데이터의 무결성을 유지하기 위한 데이터베이스의 보편적인 방법으로 테이블의 특정 칼럼에 설정하는 제약이다.

##### 제약조건의 종류

| 구분                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| PRIMARY KEY(기본키) | 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 기본키를 정의한다.<br />하나의 테이블에 하나의 기본키 제약만 정의할 수 있다.<br />기본키 제약을 정의하면 DBMS는 자동으로 UNIQUE 인덱스를 생성하며, 기본키를 구성하는 칼럼에는 NULL을 입력할 수 없다.<br />결국 '기본키 제약 = 고유키 제약 & NOT NULL 제약'이 된다. |
| UNIQUE KEY(고유키)  | 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 고유키를 정의한다.<br />단, NULL은 고유키 제약의 대상이 아니므로, NULL 값을 가진 행이 여러 개가 있더라도 고유키 제약위반이 되지 않는다. |
| NOT NULL            | NULL 값의 입력을 금지한다.<br />디폴트 상태에서는 모든 칼럼에서 NULL을 허가하고 있지만, 이 제약을 지정함으로써 해당 칼럼은 입력 필수가 된다.<br />NOT NULL을 CHECK의 일부분으로 이해할 수도 있다. |
| CHECK               | 입력할 수 있는 값의 범위 등을 제한한다.<br />CHECK 제약으로는 TRUE or FALSE로 평가할 수 있는 논리식을 지정한다. |
| FOREIGN KEY(외래키) | DBMS에서 테이블간의 관계를 정의하기 위해 기본키를 다른 테이블의 외래키로 복사하는 경우 외래키가 생성된다.<br />외래키 지정시 참조 무결성 제약 옵선을 선택할 수 있다. |

##### NULL 의미

- NULL(ASCII CODE 00)은 공백(BLANK, ASCII CODE 32)이나 숫자 0(ZERO, ASCII CODE 48)과는 다른 값이며, 조건에 맞는 데이터가 없을 때의 공집합과도 다르다. 'NULL'은 '아직 정의되지 않은 미지의 값'이거나 '현재 데ㅐ이터를 입력하지 못하는 경우'를 의미한다.

##### DEFAULT 의미

- 데이터 입력 시에 칼럼의 값이 지정되어 있지 않을 경우 기본값(DEFAULT)을 사전에 설정할 수 있다. 데이터 입력시 명시된 값을 지정하지 않은 경우(DEFAULT 값을 지정하지 않은 경우)에 NULL 값이 입력되고, DEFAULT 값을 정의 했다면 해당 칼럼에 NULL 값이 입력되지 않고, 사전에 정의된 기본값이 자동으로 입력된다.

##### 테이블 구조 확인

- 테이블을 생성한 후 테이블의 구조가 제대로 만들어졌는지 확인할 필요가 있다.

```sql
-- Oracle
DESCRIBE 테이블명;
DESC 테이블명;

-- SQL Server
sp_help 'dbo.테이블명'
```

##### SELECT 문장을 통한 테이블 생성

- SELECT 문장을 활용해서 테이블을 생성할 수 있는 방법(CTAS : Create Table ~ As Select ~)이 있다.
- 기존 테이블을 이용한 CTAS 방법을 이용할 수 있다면 칼럼별로 데이터 유형을 다시 재정의 하지 않아도 되는 장점이 있다.
- 그러나 CTAS 기법 사용시 주의할 점은 기존 테이블의 제약조건 중에 NOT NULL만 새로운 복제 테이블에 적용이 되고, 기본키, 고유키, 외래키, CHECK 등의 다른 제약 조건은 없어진다.
- 제약 조건을 추가하기 위해서는 ALTER TABLE 기능을 사용해야 한다.

##### ALTER TABLE

- ADD COLUMN : 기존 테이블에 필요한 칼럼을 추가하는 명령이다. 새롭게 추가된 칼럼은 테이블의 마지막 칼럼이 되며 칼럼의 위치를 지정할 수는 없다.

```sql
ALTER TABLE 테이블명
ADD 추가할 칼럼명 데이터 유형;
```

- DROP COLUMN : 테이블에서 필요 없는 칼럼을 삭제할 수 있으며, 데이터가 있거나 없거나 모두 삭제 가능하다. 한 번에 하나의 칼럼만 삭제 가능하며, 칼럼 삭제 후 최소 하나 이상의 칼럼이 테이블에 존재해야 한다. 주의할 부분은 한 번 삭제된 칼럼은 복구가 불
  가능하다.

```SQL
ALTER TABLE 테이블명
DROP COLUMN 삭제할 칼럼명;
```

- RENAME COLUMN : 테이블을 생성하면서 만들어졌던 칼럼명을 어떤 이유로 불가피하게 변경해야 하
  는 경우에 사용한다.

```sql
-- Oracle
ALTER TABLE 테이블명
RENAME COLUMN 변경해야 할 칼럼명 TO 새로운 칼럼명;

-- SQL Server
sp_rename 변경해야 할 칼럼명, 새로운 칼럼명, 'COLUMN';
```

- MODIFY COLUMN : 테이블에 존재하는 칼럼에 대해서 ALTER TABLE 명령을 이용해 칼럼의 데이터 유형, 디폴트(DEFAULT) 값, NOT NULL 제약조건에 대한 변경을 포함할 수 있다.

```sql
-- Oracle
ALTER TABLE 테이블명
MODIFY (칼럼명1 데이터 유형 [DEFAULT 식] [NOT NULL],
칼럼명2 데이터 유형 …);

-- SQL Server
ALTER TABLE 테이블명
ALTER (칼럼명1 데이터 유형 [DEFAULT 식] [NOT NULL],
칼럼명2 데이터 유형 …);
```

##### 칼럼 변경 시 주의 사항

- 기존의 데이터가 훼손될 수 있기 때문에 해당 칼럼의 크기를 늘릴 수는 있지만 줄이지는 못한다.
- 해당 칼럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 칼럼의 폭을 줄일 수 있다.
- 해당 칼럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.
- 해당 칼럼의 DEFAULT 값을 바꾸면 변경 작업 이후에 발생하는 행 삽입에만 영향을 미친다.
- 해당 칼럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.

##### DROP CONSTRAINT

- 테이블 생성 시 부여했던 제약조건을 삭제하는 명령어이다.

```sql
ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
```

##### ADD CONSTRAINT

- 테이블 생성 시 제약조건을 적용하지 않았다면, 생성 이후에 필요에 의해서 제약조건을 추가할 수 있다.

```sql
ALTER TABLE 테이블명
ADD CONSTRAINT 제약조건명 제약조건 (칼럼명);
```

##### RENAME TABLE

- RENAME 명령어를 사용하여 테이블의 이름을 변경할 수 있다.

```sql
-- Oracle
RENAME 변경전 테이블명 TO 변경후 테이블명;

-- SQL Server
sp_rename 변경전 테이블명, 변경후 테이블명;
```

##### DROP TABLE

- 테이블을 잘못 만들었거나 테이블이 더 이상 필요 없을 경우 해당 테이블을 삭제할 때 사용하는 명령어이다. CASCADE
  CONSTRAINT 옵션은 해당 테이블과 관계가 있었던 참조되는 제약조건에 대해서도 삭제한다는 것을 의미한다.

```sql
DROP TABLE 테이블명 [CASCADE CONSTRAINT];
```

- SQL Server에서는 CASCADE 옵션이 존재하지 않으며 테이블을 삭제하기 전에 참조하는 FOREIGN KEY 제약 조건 또는 참조하는 테이블을 먼저 삭제해야 한다.

##### TRUNCATE TABLE

- TRUNCATE TABLE은 테이블 자체가 삭제되는 것이 아니고, 해당 테이블에 들어있던 모든 행들이 제거되고 저장 공간을 재사용 가능하도록 해제한다.

```sql
TRUNCATE TABLE 테이블명;
```

##### DROP TABLE과 TRUNCATE TABLE의 차이점

- DROP TABLE의 경우는 테이블 자체가 없어지기 때문에 테이블 구조를 확인할 수 없다.
- 반면 TRUNCATE TABLE의 경우는 테이블 구조는 그대로 유지한 체 데이터만 전부 삭제하는 기능이다.

##### DML(DATA MANIPULATION LANGUAGE)

- 만들어진 테이블에 관리하기를 원하는 자료들을 입력, 수정, 삭제, 조회하는 명령어들이다.

##### INSERT

- 테이블에 데이터를 입력하는 방법은 두 가지 유형이 있으며 한 번에 한 건만 입력된다.

```sql
-- 첫 번째 유형
INSERT INTO 테이블명 (COLUMN_LIST)
VALUES (COLUMN_LIST에 넣을 VALUE_LIST);

-- 두 번째 유형
INSERT INTO 테이블명
VALUES (전체 COLUMN에 넣을 VALUE_LIST);
```

- 첫 번째 유형은 테이블의 칼럼을 정의할 수 있는데, 이때 칼럼의 순서는 테이블의 칼럼 순서와 매치할 필요는 없으며, 정의하지 않은 칼럼은 Default로 NULL 값이 입력된다. 단, Primary Key나 Not NULL 로 지정된 칼럼은 NULL이 허용되지 않는다.
- 두 번째 유형은 모든 칼럼에 데이터를 입력하는 경우로 굳이 COLUMN_LIST를 언급하지 않아도 되지만, 칼럼의 순서대로 빠짐없이 데이터가 입력되어야 한다.

##### UPDATE

- 입력한 정보 중에 잘못 입력되거나 변경이 발생하여 정보를 수정해야 하는 경우가 발생할 때 사용하는 명령어이다.

```sql
UPDATE 테이블명
SET 수정되어야 할 칼럼명 = 수정되기를 원하는 새로운 값;
```

##### DELETE

- 테이블의 정보가 필요 없게 되었을 경우 데이터 삭제를 수행하는 명령어이다.

```sql
DELETE [FROM] 삭제를 원하는 정보가 들어있는 테이블명;
```

##### DDL과 DML의 차이점

- DDL(CREATE, ALTER, RENAME, DROP) 명령어인 경우에는 직접 데이터베이스의 테이블에 영향을 미치기 때문에 DDL 명령어를 입력하는 순간 명령어에 해당하는 작업이 즉시(AUTO COMMIT) 완료된다.
- 하지만 DML(INSERT, UPDATE, DELETE, SELECT) 명령어의 경우, 조작하려는 테이블을 메모리 버퍼에 올려놓고 작업을 하기 때문
  에 실시간으로 테이블에 영향을 미치는 것은 아니다. 따라서 버퍼에서 처리한 DML 명령어가 실제 테이블에 반영되기 위해서는 COMMIT 명령어를 입력하여 TRANSACTION을 종료해야 한다.
- 테이블의 전체 데이터를 삭제하는 경우, 시스템 활용 측면에서는 삭제된 데이터를 로그로 저장하는 DELETE TABLE 보다는 시스템 부하가 적은 TRUNCATE TABLE을 권고한다. 단, TRUNCATE TABLE의 경우 삭제된 데이터의 로그가 없으므로 ROLLBACK이 불가능하므로 주의해야 한다.

##### SELECT

- 사용자가 입력한 데이터를 조회하는 명령어이다.

- SELECT ALL : Default 옵션이므로 별도로 표시하지 않아도 된다. 중복된 데이터가 있어도 모두 출력한다.

```sql
SELECT ALL 보고 싶은 칼럼명, 보고 싶은 칼럼명, ...
FROM 해당 칼럼들이 있는 테이블명;
```

- DISTINCT : 중복된 데이터가 있는 경우 1건으로 처리해서 출력한다.

```sql
SELECT DISTINCT 보고 싶은 칼럼명, 보고 싶은 칼럼명, ...
FROM 해당 칼럼들이 있는 테이블명;
```

- WILDCARD : 해당 테이블의 모든 칼럼 정보를 보고 싶을 경우에는 와일드카드로 애스터리스크(*)를 사용하여 조회할 수 있다.

```sql
SELECT *
FROM 테이블명;
```

- ALIAS : 조회된 결과에 일종의 별명(ALIAS, ALIASES)을 부여해서 칼럼 레이블을 변경할 수 있다. 칼럼 별명(ALIAS)에 대한 사항을 정리하면 다음과 같다.
  - 칼럼명 바로 뒤에 온다.
  - 칼럼명과 ALIAS 사이에 AS, as 키워드를 사용할 수도 있다. (option)
  - 이중 인용부호(Double quotation, " ")는 ALIAS가 공백, 특수문자를 포함할 경우와 대소문자 구분이 필요할 경우에 사용된다.

##### 산술 연산자

- 산술 연산자는 NUMBER와 DATE 자료형에 대해 적용되며 일반적으로 수학에서의 4칙 연산과 동일하다. 그리고 우선순위를 위한 괄호 적용이 가능하다. 그리고 산술연산자는 수학에서와 같이 (), *, /, +, - 의 우선순위를 가진다.

##### 산술 연산자의 종류

| 산술 연산자 | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| ()          | 연산자 우선순위를 변경하기 위한 괄호로 괄호 안의 연산이 우선된다. |
| \*          | 곱하기                                                       |
| /           | 나누기                                                       |
| +           | 더하기                                                       |
| -           | 빼기                                                         |

##### 합성(CONCATENATION) 연산자

- 문자와 문자를 연결하는 합성(CONCATENATION) 연산자를 사용하면 별도의 프로그램 도움 없이도 SQL 문장만으로도 유용한 리포트를 출력할 수 있다.

##### 합성 연산자의 특징

- 문자와 문자를 연결하는 경우 2개의 수직 바(||)에 의해 이루어진다. (Oracle)
- 문자와 문자를 연결하는 경우 + 표시에 의해 이루어진다. (SQL Server)
- 두 벤더 모두 공통적으로 CONCAT (String 1, String 2) 함수를 사용할 수 있다.
- 칼럼과 문자 또는 다른 칼럼과 연결시킨다.
- 문자 표현식의 결과에 의해 새로운 칼럼을 생성한다.

##### 트랜잭션(TRANSACTION)

- 트랜잭션(TRANSACTION)이란 밀접히 관련되어 분리될 수 없는 한 개 이상의 데이터베이스 조작을 가리킨다.
- 하나의 트랜잭션에는 하나 이상의 SQL 문장이 포함된다.
- 트랜잭션은 분할할 수 없는 최소의 단위이다.

##### 트랜잭션의 특성

| 특성                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 원자성(atomicity)   | 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실해오디지 않은 상태로 남아 있어야 한다. (all or nothing) |
| 일관성(consistency) | 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다. |
| 고립성(isolation)   | 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다. |
| 지속성(durability)  | 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다. |

- 트랜잭션의 특성(특히 원자성)을 충족하기 위해 데이터베이스는 다양한 레벨의 잠금 기능을 제공하고 있는데, 잠금은 기본적으로 트랜잭션이 수행하는 동안 특정 데이터에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 제한하는 기법이다.
- 잠금이 걸린 데이터는 잠금을 실행한 트랜잭션만 독점적으로 접근할 수 있고 다른 트랜잭션으로부터 간섭이나 방해를 받지 않는 것이 보장된다. 그리고 잠금이 걸린 데이터는 잠금을 수행한 트랜잭션만이 해제할 수 있다.

##### COMMIT

- 입력한 자료나 수정한 자료에 대해서 또는 삭제한 자료에 대해서 전혀 문제가 없다고 판단되었을 경우 COMMIT 명령어를 통해서 트랜잭션을 완료할 수 있다.
- COMMIT 명령어는 INSERT 문장, UPDATE 문장, DELETE 문장을 사용한 후에 이런 변경 작업이 완료되었음을 데이터베이스에 알려 주기 위해 사용한다. 
- 하지만, SQL Server는 기본적으로 AUTO COMMIT 모드이기 때문에 DML 수행 후 사용자가 COMMIT이나 ROLLBACK을 처리할 필요가 없다. DML 구문이 성공이면 자동으로 COMMIT이 되고 오류가 발생할 경우 자동으로 ROLLBACK 처리된다.

```sql
COMMIT;
```

##### COMMIT이나 ROLLBACK 이전의 데이터 상태

- 단지 메모리 BUFFER에만 영향을 받았기 때문에 데이터의 변경 이전 상태로 복구 가능하다.
- 현재 사용자는 SELECT 문장으로 결과를 확인 가능하다.
- 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없다.
- 변경된 행은 잠금(LOCKING)이 설정되어서 다른 사용자가 변경할 수 없다.

##### COMMIT 이후의 데이터 상태

- 데이터에 대한 변경 사항이 데이터베이스에 반영된다.
- 이전 데이터는 영원히 잃어버리게 된다.
- 모든 사용자는 결과를 볼 수 있다.
- 관련된 행에 대한 잠금(LOCKING)이 풀리고, 다른 사용자들이 행을 조작할 수 있게 된다.

##### SQL Server에서의 트랜잭션

- AUTO COMMIT : SQL Server의 기본 방식이며, DML, DDL을 수행할 때마다 DBMS가 트랜잭션을 컨트롤 하는 방식이다. 명령어가 성공적으로 수행되면 자동으로 COMMIT을 수행하고 오류가 발생하면 자동으로 ROLLBACK을 수행한다.
- 암시적 트랜잭션 : Oracle과 같은 방식으로 처리된다. 즉, 트랜잭션의 시작은 DBMS가 처리하고 트랜잭션의 끝은 사용자가 명시적으로 COMMIT 또는 ROLLBACK으로 처리한다.
- 명시적 트랜잭션  : 트랜잭션의 시작과 끝을 모두 사용자가 명시적으로 지정하는 방식이다. BEGIN TRANSACTION (BEGIN TRAN 구문도 가능)으로 트랜잭션을 시작하고 COMMIT TRANSACTION(TRANSACTION은 생략 가능) 또는 ROLLBACK TRANSACTION
  (TRANSACTION은 생략 가능)으로 트랜잭션을 종료한다. ROLLBACK 구문을 만나면 최초의 BEGIN TRANSACTION 시점까지 모두 ROLLBACK이 수행된다.

##### ROLLBACK

- 테이블 내 입력한 데이터나, 수정한 데이터, 삭제한 데이터에 대하여 COMMIT 이전에는 변경 사항을 취소할 수 있는데 데이터베이스에서는 롤백 기능을 사용한다.
- 롤백은 데이터 변경 사항이 취소되어 데이터의 이전 상태로 복구되며, 관련된 행에 대한 잠금(LOCKING)이 풀리고 다른 사용자들이 데이터 변경을 할 수 있게 된다.

```sql
ROLLBACK;
```

##### SQL Server의 ROLLBACK

- SQL Server는 위에서 언급한 바와 같이 AUTO COMMIT이 기본 방식이므로 임의적으로 ROLLBACK을 수행하려면 명시적으로 트랜잭션을 선언해야 한다.

##### ROLLBACK 이후의 데이터 상태

- 데이터에 대한 변경 사항은 취소된다.
- 이전 데이터는 다시 재저장된다.
- 관련된 행에 대한 잠금(LOCKING)이 풀리고, 다른 사용자들이 행을 조작할 수 있게 된다.

##### COMMIT과 ROLLBACK의 효과

- 데이터 무결성 보장
- 영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능
- 논리적으로 연관된 작업을 그룹핑하여 처리 가능

##### 저장점(SAVEPOINT)

- 저장점(SAVEPOINT)을 정의하면 롤백할 때 트랜잭션에 포함된 전체 작업을 롤백하는 것이 아니라 현 시점에서 SAVEPOINT까지 트랜잭션의 일부만 롤백할 수 있다.
- 복잡한 대규모 트랜잭션에서 에러가 발생했을 때 SAVEPOINT까지의 트랜잭션만 롤백하고 실패한 부분에 대해서만 다시 실행할 수 있다. (일부 툴에서는 지원이 안 될 수 있음)
- 복수의 저장점을 정의할 수 있으며, 동일이름으로 저장점을 정의했을 때는 나중에 정의한 저장점이 유효하다.

```sql
-- Oracle
-- SVPT1이라는 저장점을 정의
SAVEPOINT SVPT1;

-- 저장점까지 롤백할 때는 ROLLBACK 뒤에 저장점 명을 지정한다.
ROLLBACK TO SVPT1;

-- SQL Server는 SAVE TRANSACTION을 사용하여 동일한 기능을 수행할 수 있다.
-- SVTR1이라는 저장점을 정의
SAVE TRANSACTION SVTR1;

-- 저장점까지 롤백할 때는 ROLLBACK 뒤에 저장점 명을 지정한다.
ROLLBACK TRANSACTION SVTR1;
```

##### WHERE 조건절

- 사용자들은 자신이 원하는 자료만을 검색하기 위해서 SQL 문장에 WHERE 절을 이용하여 자료들에 대하여 제한할 수 있다.
- WHERE 절에는 두 개 이상의 테이블에 대한 조인 조건을 기술하거나 결과를 제한하기 위한 조건을 기술할 수도 있다.

```sql
SELECT [DISTINCT/ALL] 칼럼명 [ALIAS명]
FROM 테이블명
WHERE 조건식;
```

##### WHERE 절의 조건식

- 칼럼(Column)명 (보통 조건식의 좌측에 위치)
- 비교 연산자
- 문자, 숫자, 표현식 (보통 조건식의 우측에 위치)
- 비교 칼럼명 (JOIN 사용시)

##### 연산자의 종류

- 비교 연산자 (부정 비교 연산자 포함)
- SQL 연산자 (부정 SQL 연산자 포함)
- 논리 연산자

##### 비교 연산자의 종류

| 연산자 | 연산자의 의미     |
| ------ | ----------------- |
| =      | 같다.             |
| >      | 보다 크다.        |
| >=     | 보다 크거나 같다. |
| <      | 보다 작다.        |
| <=     | 보다 작거나 같다. |


##### 부정 비교 연산자의 종류

| 연산자       | 연산자의 의미                                      |
| ------------ | -------------------------------------------------- |
| !=           | 같지 않다.                                         |
| ^=           | 같지 않다.                                         |
| <>           | 같지 않다. (ISO 표준, 모든 운영체제에서 사용 가능) |
| NOT 칼럼명 = | ~와 같지 않다.                                     |
| NOT 칼럼명 > | ~보다 크지 않다.                                   |

##### SQL 연산자의 종류

| 연산자            | 연산자의 의미                                         |
| ----------------- | ----------------------------------------------------- |
| BETWEEN A AND B   | A와 B의 값 사이에 있으면 된다. (A와 B 값이 포함된다.) |
| IN (LIST)         | 리스트에 있는 값 중에서 어느 하나라도 일치하면 된다.  |
| LIKE '비교문자열' | 비교문자열과 형태가 일치하면 된다. (&, _ 사용)        |
| IS NULL           | NULL 값인 경우                                        |

##### 부정 SQL 연산자의 종류

| 연산자              | 연산자의 의미                                              |
| ------------------- | ---------------------------------------------------------- |
| NOT BETWEEN A AND B | A와 B의 값 사이에 있지 않다. (A와 B 값을 포함하지 않는다.) |
| NOT IN (LIST)       | LIST 값과 일치하지 않는다.                                 |
| IS NOT NULL         | NULL 값을 갖지 않는다.                                     |

##### 논리 연산자

| 연산자 | 연산자의 의미                                                |
| ------ | ------------------------------------------------------------ |
| AND    | 앞에 있는 조건과 뒤에 오는 조건이 참(TRUE)이 되면 결과도 참(TRUE)이 된다.<br />즉, 앞의 조건과 뒤의 조건을 동시에 만족해야 한다. |
| OR     | 앞의 조건이 참(TRUE)이거나 뒤의 조건이 참(TRUE)이 되면 결과도 참(TRUE)이 된다.<br />즉, 앞의뒤의 조건 중 하나만 참(TRUE)이면 된다. |
| NOT    | 뒤에 오는 조건에 반대되는 결과를 되돌려준다.                 |

##### 연산자의 우선순위

| 연산 우선순위 | 설명                         |
| ------------- | ---------------------------- |
| 1             | 괄호()                       |
| 2             | NOT 연산자                   |
| 3             | 비교 연산자, SQL 비교 연산자 |
| 4             | AND                          |
| 5             | OR                           |

- 괄호로 묶은 연산이 제일 먼저 연산 처리된다.
- 연산자들 중에는 부정 연산자(NOT)가 먼저 처리된다.
- 비교연산자(=, >, >=, <, <=)와 SQL 비교연산자(BETWEEN A AND B, IN (LIST), LIKE, IS NULL)가 처리된다.
- 논리 연산자 중에서는 AND, OR의 순으로 처리된다.
- 만일 이러한 연산에 있어서 연산자들의 우선순위를 염두에 두지 않고 WHERE 절을 작성한다면 테이블에서 자기가 원하는 자료를 찾지 못하거나, 혹은 틀린 자료인지도 모른 채 사용할 수도 있다.

##### 문자 유형 비교 방법

- 비교 연산자의 양쪽이 모두 CHAR 유형 타입인 경우
  - 길이가 서로 다른 CHAR형 타입이면, 작은 쪽에 SPACE를 추가하여 길이를 같게 한 후에 비교한다.
  - 서로 다른 문자가 나올 때 까지 비교한다.
  - 달라진 첫 번째 문자의 값에 따라 크기를 결정한다.
  - BLANK의 수만 다르다면 서로 같은 값으로 결정한다.
- 비교 연산자의 어느 한 쪽이 VARCHAR 유형 타입인 경우
  - 서로 다른 문자가 나올 때 까지 비교한다.
  - 길이가 다르다면 짧은 것이 끝날 때까지만 비교 후에 길이가 긴 것이 크다고 판단한다.
  - 길이가 같고 다른 것이 없다면 같다고 판단한다.
  - VARCHAR는 NOT NULL까지 길이를 말한다.
- 상수값과 비교할 경우
  - 상수 쪽을 변수 타입과 동일하게 바꾸고 비교한다.
  - 변수 쪽이 CHAR 유형 타입이면 위의 CHAR 유형 타입의 경우를 적용한다.
  - 변수 쪽이 VARCHAR 유형 타입이면 위의 VARCHAR 유형 타입의 경우를 적용한다.

##### 와일드카드

- 한 개 혹은 0개 이상의 문자를 대신해서 사용하기 위한 특수 문자를 의미하며, 조합하여 사용하는 것도 가능하므로 SQL 문장에서 사용하는 STRING 값으로 용이하게 사용할 수 있다.

##### 와일드카드의 종류

| 와일드 카드 | 설명                             |
| ----------- | -------------------------------- |
| %           | 0개 이상의 어떤 문자를 의미한다. |
| _           | 1개인 단일 문자를 의미한다.      |

##### ROWNUM

- Oracle의 ROWNUM은 칼럼과 비슷한 성격의 Pseudo Column으로써 SQL 처리 결과 집합의 각 행에 대해 임시로 부여되는 일련번호이며, 테이블이나 집합에서 원하는 만큼의 행만 가져오고 싶을 때 WHERE 절에서 행의 개수를 제한하는 목적으로 사용한다.

```sql
-- 한 건의 행만 가져오고 싶을 때
SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM = 1;
SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM <= 1;
SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM <2;
-- 두 건 이상의 N 행을 가져오고 싶을 때
SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM <= N;
SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM <= N+1;
```

- 추가적인 ROWNUM의 용도로는 테이블 내의 고유한 키나 인덱스 값을 만들 수 있다.

```sql
UPDATE MY_TABLE SET COLUMN1 = ROWNUM;
```

##### TOP

- SQL Server는 TOP 절을 사용하여 결과 집합으로 출력되는 행의 수를 제한할 수 있다.

```sql
TOP (Expression) [PERCENT] [WITH TIES]
```

- Expression : 반환할 행의 수를 지정하는 숫자이다.
- PERCENT : 쿼리 결과 집합에서 처음 Expression%의 행만 반환됨을 나타낸다.
- WITH TIES : ORDER BY 절이 지정된 경우에만 사용할 수 있으며, TOP N(PERCENT)
의 마지막 행과 같은 값이 있는 경우 추가 행이 출력되도록 지정할 수 있다.

```sql
-- 한 건의 행만 가져오고 싶을 때
SELECT TOP(1) PLAYER_NAME FROM PLAYER;
-- 두 건 이상의 N 행을 가져오고 싶을 때
- SELECT TOP(N) PLAYER_NAME FROM PLAYER;
```

##### 함수의 종류

- 내장 함수(Built-in Function) : 벤더에서 제공하는 함수
  - 단일행 함수(Single-Row Function) : 함수의 입력 값이 단일행 값이 입력되는 함수
  - 다중행 함수(Multi-Row Function) : 여러 행의 값이 입력되는 함수
    - 집계 함수(Aggregate Function)
    - 그룹 함수(Group Function)
    - 윈도우 함수(Window Function)
- 사용자가 정의할 수 있는 함수(User Defined Function) : 사용자가 정의할 수 있는 함수

##### 단일행 함수의 종류

- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

| 종류           | 내용                                            | 함수의 예                                                    |
| -------------- | ----------------------------------------------- | ------------------------------------------------------------ |
| 문자형 함수    | 문자를 입력하면 문자나 숫자 값을 반환한다.      | LOWER, UPPER, SUBSTR/SUBSTRING, LENGTH/LEN, LTRIM, RTRIM, TRIM, ASCII |
| 숫자형 함수    | 숫자를 입력하면 숫자 값을 반환한다.             | ABS, MOD, ROUND, TRUNC, SIGN, CHR/CHAR, CEIL/CEILING, FLOOR, EXP, LOG, LN, POWER, SIN, COS, TAN |
| 날짜형 함수    | DATE 타입의 값을 연산한다.                      | SYSDATE/GETDATE, EXTRACT/DATEPART, TO_NUMBER(TO_CHAR(D,'YYYY'\|'MM'\|'DD'))/YEAR\|MONTH\|DAY |
| 변환형 함수    | 문자, 숫자, 날짜형 값의 데이터 타입을 변환한다. | TO_NUMBER, TO_CHAR, TO_DATE/CAST, CONVERT                    |
| NULL 관련 함수 | NULL                                            | NVL/ISNULL, NULLIF, COALESCE                                 |

##### 단일행 함수 특징

- SELECT, WHERE, ORDER BY 절에 사용 가능하다.
- 각 행(Row)들에 대해 개별적으로 작용하여 데이터 값들을 조작하고, 각각의 행에 대한 조작 결과를 리턴한다.\- 여러 인자(Argument)를 입력해도 단 하나의 결과만 리턴한다.
- 함수의 인자(Arguments)로 상수, 변수, 표현식이 사용 가능하고, 하나의 인수를 가지는 경우도 있지만 여러 개의 인수를 가질 수도 있다.
- 특별한 경우가 아니면 함수의 인자(Arguments)로 함수를 사용하는 함수의 중첩이 가능하다.

##### 문자형 함수

- 문자형 함수는 문자 데이터를 매개 변수로 받아들여서 문자나 숫자 값의 결과를 돌려주는 함수이다. 몇몇 문자형 함수의 경우는 결과를 숫자로 리턴하는 함수도 있다.

##### 단일행 문자형 함수의 종류

- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

| 문자형 함수                                              | 함수 설명                                                    |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| LOWER(문자열)                                            | 문자열의 알파벳 문자를 소문자로 바꾸어준다.                  |
| UPPER(문자열)                                            | 문자열의 알파벳 문자를 대문자로 바꾸어준다.                  |
| ASCII(문자)                                              | 문자나 숫자를 ASCII CODE로 바꾸어준다.                       |
| CHR/CHAR(ASCII CODE)                                     | ASCII CODE를 문자나 숫자로 바꾸어준다.                       |
| CONCAT (문자열1, 문자열2)                                | Oracle, MySQL에서 유효한 함수이며 문자열1과 문자열2를 연결한다.<br />합성연산자 '\|\|' (Oracle)나 '+'(SQL Server)와 동일하다. |
| SUBSTR/SUBSTRING (문자열, m[, n ])                       | 문자열 중 m의 위치에서 n개의 문자 길이에 해당하는 문자를 돌려준다.<br />n이 생략되면, 마지막 문자까지 이다. |
| LENGTH/LEN(문자열)                                       | 문자열의 개수를 숫자값으로 돌려준다.                         |
| LTRIM (문자열, [, 지정문자])                             | 문자열의 첫 문자부터 확인해서 지정 문자가 나타나면 해당 문자를 제거한다. (지정문자가 생략되면 공백 값이 디폴트)<br />SQL Server에서는 LTRIM 함수에 지정문자를 사용할 수 없다. 즉, 공백만 제거할 수 있다. |
| RTRIM (문자열, [, 지정문자])                             | 문자열의 마지막 문자부터 확인해서 지정 문자가 나타나면 해당 문자를 제거한다. (지정문자가 생략되면 공백 값이 디폴트)<br />SQL Server에서는 RTRIM 함수에 지정문자를 사용할 수 없다. 즉, 공백만 제거할 수 있다. |
| TRIM([leading \| trailing \| both] 지정문자 FROM 문자열) | 문자열에서 머리말, 꼬리말, 또는 양쪽에 있는 지정문자를 제거한다. (leading \| trailing \| both 가 생략되면 both가 디폴트)<br />SQL Server에서는 TRIM 함수에 지정문자를 사용할 수 없다. 즉, 공백만 제거할 수 있다. |

##### 단일행 문자형 함수 사례

| 문자형 함수 사용                                             | 결과 값 및 설명                         |
| ------------------------------------------------------------ | --------------------------------------- |
| LOWER('SQL Expert')                                          | 'sql expert'                            |
| UPPER('SQL Expert')                                          | 'SQL EXPERT'                            |
| ASCII('A')                                                   | 65                                      |
| CHR(65) / CHAR(65)                                           | 'A'                                     |
| CONCAT('RDMBS', ' SQL')<br />'RDBMS' \|\| ' SQL' / 'RDBMS ' + ' SQL' | 'RDBMS SQL'                             |
| SUBSTR('SQL Expert', 5, 3)<br />SUBSTRING('SQL Expert', 5, 3) | 'Exp'                                   |
| LENGTH('SQL Expert')<br />LEN('SQL Expert')                  | 10                                      |
| LTRIM('xxxYYZZxYZ', 'x')<br />RTRIM('XXYYzzXYzz','z')<br />TRIM('x' FROM 'xxYYZZxYZxx') | 'YYZZxYZ'<br />'XXYYzzXY'<br />'YYZxYZ' |
| RTRIM('XXYYZZXYZ.         ')<br />-> 공백 제거 및 CHAR와 VARCHAR 데이터 유형을 비교할 때 용이하게 사용된다. | 'ㄱXXYYZZXYZ'                           |

##### Oracle의 DUAL 테이블

- 사용자 SYS가 소유하며 모든 사용자가 액세스 가능한 테이블이다.
- SELECT ~ FROM ~ 의 형식을 갖추기 위한 일종의 DUMMY 테이블이다.
- DUMMY라는 문자열 유형의 칼럼에 'X'라는 값이 들어 있는 행을 1건 포함하고 있다.

##### 숫자형 함수

- 숫자형 함수는 숫자 데이터를 입력받아 처리하고 숫자를 리턴하는 함수이다.

##### 단일행 숫자형 함수의 종류

- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

| 숫자형 함수                         | 함수 설명                                                    |
| ----------------------------------- | ------------------------------------------------------------ |
| ABS(숫자)                           | 숫자와 절대값을 돌려준다.                                    |
| SIGN(숫자)                          | 숫자가 양수인지, 음수인지, 0인지를 구별한다.                 |
| MOD(숫자1, 숫자2)                   | 숫자1을 숫2로 나누어 나머지 값을 리턴한다.<br />MOD 함수는 % 연산자로도 대체 가능하다. |
| CEIL/CEILING(숫자)                  | 숫자보다 크거나 같은 최소 정수를 리턴한다.                   |
| FLOOR(숫자)                         | 숫자보다 작거나 같은 최대 정수를 리턴한다.                   |
| ROUND(숫자, [, m])                  | 숫자를 소수점 m자리에서 반올림하여 리턴한다.<br />m이 생략되면 디폴트 값은 0이다. |
| TRUNC(숫자, [, m])                  | 숫자를 소수 m자리에서 잘러서 버린다.<br />m이 생략되면 디폴트 값은 0이다.<br />SQL Server에서 TRUNC 함수는 제공되지 않는다. |
| SIN, COS, TAN, ...                  | 숫자의 삼각함수 값을 리턴한다.                               |
| EXP(), POWER(), SQRT(), LOG(), LN() | 숫자의 지수, 거듭 제곱, 제곱근, 자연 로그 값을 리턴한다.     |

##### 단일행 숫자형 함수 사례

- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

| 숫자형 함수 사용                                             | 결과 값                                             |
| ------------------------------------------------------------ | --------------------------------------------------- |
| ABS(-15)                                                     | 15                                                  |
| SIGN(-20)<br />SIGN(0)<br />SIGN(+20)                        | -1<br />0<br />1                                    |
| MOD(7,3 ) / <br />7%3                                        | 1                                                   |
| CEIL(38.123) / <br />CEILING(38.123)<br />CEILING(-38.123)   | 39<br />39<br />-38                                 |
| FLLOR(38.123)<br />FLOOR(-38.123)                            | 38<br />-39                                         |
| ROUND(38.5235, 3)<br />ROUND(38.5235, 1)<br />ROUND(38.5235, 0)<br />ROUND(38.5235) | 38.524<br />38.5<br />39<br />39 (인수 0이 Default) |
| TRUNC(38.5235, 3)<br />TRUNC(38.5235, 1)<br />TRUNC(38.5235, 0)<br />TRUNC(38.5235) | 38.523<br />28.5<br />38<br />38 (인수 0이 Default) |

##### 날짜형 함수

- 날짜형 함수는 DATE 타입의 값을 연산하는 함수이다. 

##### 단일행 날짜형 함수의 종류

- Oracle의 TO_NUMBER(TO_CHAR()) 함수의 경우 변환형 함수로 구분할 수도 있으나 SQL Server의 YEAR, MONTH, DAY 함수와 매핑하기 위하여 날짜형 함수에 대해서 설명한다.
- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

| 날짜형 함수                                                  | 함수 설명                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| SYSDATE / GETDATE()                                          | 현재 날짜와 시각을 출력한다.                                 |
| EXTRACT('YEAR'\|'MONTH'\|'DAY' from d) / DATEPART('YEAR'\|'MONTH'\|'DAY', d) | 날짜 데이터에서 년/월/일 데이터를 출력할 수 있다.<br />시간/분/초도 가능하다. |
| TO_NUMBER(TO_CHAR(d,'YYYY')) / YEAR(d)<br />TO_NUMBER(TO_CHAR(d,'MM')) / MONTH(d)<br />TO_NUMBER(TO_CHAR(d,'DD')) / DAY(d) | 날짜 데이터에서 년/월/일 데이터를 출력할 수 있다.<br />Oracle EXTRACT YEAR/MONTH/DAY 옵션이나 SQL Server DEPART YEAR/MONTH/DAY 옵션과 같은 기능이다.<br />TO_NUMBER 함수 제외시 문자형으로 출력된다. |

##### 단일행 날짜형 데이터 연산

| 연산           | 결과   | 설명                                                   |
| -------------- | ------ | ------------------------------------------------------ |
| 숫자 + 숫자    | 날짜   | 숫자만큼 날수를 날짜에 더한다.                         |
| 날짜 - 숫자    | 날짜   | 숫자만큼의 날수를 날짜에서 뺀다.                       |
| 날짜1  - 날짜2 | 날짜수 | 다른 하나의 날짜에서 하나의 날짜를 빼면 일수가 나온다. |
| 날짜 + 숫자/24 | 날짜   | 시간을 날짜에 더한다.                                  |

##### 변환형 함수

- 변환형 함수는 특정 데이터 타입을 다양한 형식으로 출력하고 싶을 경우에 사용되는 함수이다.

##### 변환형 함수의 종류

| 종류                              | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| 명시적(Explicit) 데이터 유형 변환 | 데이터 변환형 함수로 데이터 유형을 변환하도록 명시해주는 경우 |
| 암시적(Implicit) 데이터 유형 변환 | 데이터베이스가 자동으로 데이터 유형을 변환하여 계산하는 경우 |

##### 명시적 데이터 유형 변환에 사용되는 함수의 종류(단일행 변환형 함수)

| 변환형 함수 - Oracle             | 함수 설명                              |
| -------------------------------- | -------------------------------------- |
| TO_NUMBER(문자열)                | alphanumeric 문자열을 숫자로 변환한다. |
| TO_CAHR(숫자 \| 날짜 [, FORMAT]) | FORMAT                                 |
| TO_DATE(문자열 [, FORMAT])       | FORMAT                                 |

| 변환형 함수 - SQL Server                             | 함수 설명                                   |
| ---------------------------------------------------- | ------------------------------------------- |
| CAST (expression AS data_type [(length)])            | expression을 목표 데이터 유형으로 변환한다. |
| CONVERT (data_type [(length)], expression [, style]) | expression을 목표 데이터 유형으로 변환한다. |


##### 명시적 데이터 유형 변환에 사용되는 함수의 종류(단일행 변환형 함수)

- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

##### CASE 표현

- CASE 표현은 IF-THEN-ELSE 논리와 유사한 방식으로 표현식을 작성해서 SQL의 비교 연산 기능을 보완하는 역할을 한다. ANSI/ISO SQL 표준에는 CASE Expression이라고 표시되어 있는데, 함수와 같은 성격을 가지고 있으며, Oracle의 Decode 함수와 같은 기능을 한다.

##### 단일행 CASE 표현의 종류

| CASE 표현                                                    | 함수 설명                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| CASE<br />     SIMPLE_CASE_EXPRESSION 조건<br />     ELSE 표현절<br />END | SIMPLE_CASE_EXPRESSION 조건이 맞으면 SIMPLE_CASE_EXPRESSION  조건 내의 THEN 절을 수행하고, 조건이 맞지 않으면 ELSE 절을 수행한다. |
| CASE<br />     SEARCHED_CASE_EXPRESSION 조건<br />     ELSE 표현절<br />END | SEARCHED_CASE_EXPRESSION 조건이 맞으면 SEARCHED_CASE_EXPRESSION 조건 내의 THEN 절을 수행하고, 조건이 맞지 않으면 ELSE 절을 수행한다. |
| DECODE(표현식, 기준값1, 값1 [, 기준값2, 값2, ... , 디폴트값]) | Oracle에서만 사용되는 함수로, 표션기의 값이 기준값1이면 값1을 출력하고 기준값2면 값2를 출력한다. 그리고 기준값이 없으면 디폴트 값을 출력한다.<br />CASE 표현의 SIMPLE_CASE_EXPRESSION 조건과 동일하다. |

##### 단일행 CASE 표현의 예제

```sql
CASE
	SIMPLE_CASE_EXPRESSION 조건 or SEARCHED_CASE_EXPRESSION 조건 ELSE 표현절
END
```

```sql
CASE
	EXPR WHEN COMPARISON_EXPR THEN RETURN_EXPR
	ELSE 표현절
END
```

```sql
CASE
	WHEN CONDITION THEN RETURN_EXPR
	ELSE 표현절
END
```

##### NULL 포함 연산의 결과

| 연산               | 연산 결과 |
| ------------------ | --------- |
| NULL + 2, 2 + NULL | NULL      |
| NULL - 2, 2 - NULL | NULL      |
| NULL * 2, 2 * NULL | NULL      |
| NULL / 2, 2 / NULL | NULL      |

##### 단일행 NULL 관련 함수의 종류

- '/'가 없는 것은 공통 함수이지만, '/'가 있는 건 Oracle 함수/SQL Server 함수 순서이다.

| 일반형 함수                                      | 함수 설명                                                    |
| ------------------------------------------------ | ------------------------------------------------------------ |
| NVL(표현식1, 표현식2) / ISNULL(표현식1, 표현식2) | 표현식1의 결과값이 NULL이면 표현식2의 값을 출력한다.<br />단, 표현식1과 표현식2의 결과 데이터 값이 같아야 한다.<br />NULL 관련 가장 많이 사용되는 함수이므로 상당히 중요하다. |
| NULLIF(표현식1, 표현식2)                         | 표현식1이 표현식2와 같으면 NULL을, 같지 않으면 표현식1을 리턴한다. |
| COALESCE(표현식1, 표현식2, ...)                  | 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타낸다.<br />모든 표현식이 NULL이라면 NULL을 리턴한다. |

##### NULLIF

- NULLIF 함수는 EXPR1이 EXPR와 같으면 NULL을, 같지 않으면 EXRP1을 리턴한다. 특정 값을 NULL로 대체하는 경우에 유용하게 사용할 수 있다.

```sql
NULLIF (EXPR1, EXPR2)
```

##### 기타 NULL 관련 함수 (COALESCE)

- COALESCE 함수는 인수의 숫자가 한정되어 있지 않으며, 임의의 개수 EXPR에서 NULL이 아닌 최초의 EXPR을 나타낸다. 만일 모든 EXPR이 NULL이라면 NULL을 리턴한다.

```sql
COALESCE (EXPR1, EXPR2, ...)
```

##### 집계 함수(Aggregate Function)

- 여러 행들의 그룹이 모여서 그룹당 단 하나의 결과를 돌려주는 다중행 함수이다.

##### 집계 함수(Aggregate Function)의 특성

- 여러 행들의 그룹이 모여서 그룹당 단 하나의 결과를 돌려주는 함수이다.
- GROUP BY 절은 행들을 소그룹화 한다.
- SELECT 절, HAVING 절, ORDER BY 절에 사용할 수 있다.

```sql
집계 함수명 ( [DISTINCT | ALL] 칼럼이나 표현식 )
```

##### 집계 함수의 종류

| 집계 함수                        | 사용 목적                                                    |
| -------------------------------- | ------------------------------------------------------------ |
| COUNT(*)                         | NULL 값을 포함한 행의 수를 출력한다.                         |
| COUNT(표현식)                    | 표현식의 값이 NULL 값인 것을 제외한 행의 수를 출력한다.      |
| SUM([DISTINCT \| ALL] 표현식)    | 표현식의 NULL 값을 제외한 합계를 출력한다.                   |
| AVG([DISTINCT \| ALL] 표현식)    | 표현식의 NULL 값을 제외한 평균을 출력한다.                   |
| MAX([DISTINCT \| ALL] 표현식)    | 표현식의 최대값을 출력한다. (문자, 날짜 데이터 타입도 사용 가능) |
| MIN([DISTINCT \| ALL] 표현식)    | 표현식의 최소값을 출력한다. (문자, 날짜 데이터 타입도 사용 가능) |
| STDDEV([DISTINCT \| ALL] 표현식) | 표현식의 표준 편차를 출력한다.                               |
| VARIAN([DISTINCT \| ALL] 표현식) | 표현식의 분산을 출력한다.                                    |
| 기타 통계 함수                   | 벤더별로 다양한 통계식을 제공한다.                           |

##### GROUP BY 절

- GROUP BY 절은 SQL 문에서 FROM 절과 WHERE 절 뒤에 오며, 데이터들을 작은 그룹으로 분류하여 소그룹에 대한 항목별로 통계 정보를 얻을 때 추가로 사용된다.

```sql
SELECT [DISTINCT] 칼럼명 [ALIAS명]
FROM 테이블명
[WHERE 조건식]
[GROUP BY 칼럼(Column)이나 표현식]
[HAVING 그룹조건식];
```

##### GROUP BY 절과 HAVING 절의 특성

- GROUP BY 절을 통해 소그룹별 기준을 정한 후, SELECT 절에 집계 함수를 사용한다.
- 집계 함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행한다.
- GROUP BY 절에서는 SELECT 절과는 달리 ALIAS 명을 사용할 수 없다.
- 집계 함수는 WHERE 절에는 올 수 없다. (집계 함수를 사용할 수 있는 GROUP BY 절보다 WHERE 절이 먼저 수행된다.)
- WHERE 절은 전체 데이터를 GROUP으로 나누기 전에 행들을 미리 제거시킨다.
- HAVING 절은 GROUP BY 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건을 표시할 수 있다.
- GROUP BY 절에 의한 소그룹별로 만들어진 집계 데이터 중, HAVING 절에서 제한 조 건을 두어 조건을 만족하는 내용만 출력한다.
- HAVING 절은 일반적으로 GROUP BY 절 뒤에 위치한다.

##### HAVING 절

- HAVING 절은 WHERE 절과 비슷하지만 그룹을 나타내는 결과 집합의 행에 조건이 적용된다는 점에서 차이가 있다.
- WHERE 절의 조건 변경은 대상 데이터의 개수가 변경되므로 결과 데이터 값이 변경될 수 있지만, HAVING 절의 조건 변경은 결과 데이터 변경은 없고 출력되는 레코드의 개수만 변경될 수 있다.

##### ORDER BY 정렬

- ORDER BY 절은 SQL 문장으로 조회된 데이터들을 다양한 목적에 맞게 특정 칼럼을 기준으로 정렬하여 출력하는데 사용한다.
- ORDER BY 절에 칼럼(Column)명 대신에 SELECT 절에서 사용한 ALIAS 명이나 칼럼 순서를 나타내는 정수도 사용 가능하다.
-  별도로 정렬 방식을 지정하지 않으면 기본 적으로 오름차순이 적용되며, SQL 문장의 제일 마지막에 위치한다.

```sql
SELECT 칼럼명 [ALIAS명]
FROM 테이블명
[WHERE 조건식]
[GROUP BY 칼럼(Column)이나 표현식] [HAVING 그룹조건식]
[ORDER BY 칼럼(Column)이나 표현식 [ASC 또는 DESC]];
-- ASC(Ascending) : 조회한 데이터를 오름차순으로 정렬한다. (기본 값이므로 생략 가능)
-- DESC(Descending) : 조회한 데이터를 내림차순으로 정렬한다.
```

##### ORDER BY 절의 특징

- 기본적인 정렬 순서는 오름차순(ASC)이다.
- 숫자형 데이터 타입은 오름차순으로 정렬했을 경우에 가장 작은 값부터 출력된다
- 날짜형 데이터 타입은 오름차순으로 정렬했을 경우 날짜 값이 가장 빠른 값이 먼저 출력 된다. (예를 들어 ‘01-JAN-2012’는 ‘01-SEP-2012’보다 먼저 출력된다.)
- Oracle에서는 NULL 값을 가장 큰 값으로 간주하여 오름차순으로 정렬했을 경우에는 가 장 마지막에, 내림차순으로 정렬했을 경우에는 가장 먼저 위치한다.
- 반면, SQL Server에서는 NULL 값을 가장 작은 값으로 간주하여 오름차순으로 정렬했을 경우에는 가장 먼저, 내림차순으로 정렬했을 경우에는 가장 마지막에 위치한다.

##### SELECT 문장 실행 순서

```sql
5. SELECT 칼럼명 [ALIAS명]
1. FROM 테이블명
2. WHERE 조건식
3. GROUP BY 칼럼(Column)이나 표현식 4. HAVING 그룹조건식
6. ORDER BY 칼럼(Column)이나 표현식;
```

1. 발췌 대상 테이블을 참조한다. (FROM)
2. 발췌 대상 데이터가 아닌 것은 제거한다. (WHERE)
3. 행들을 소그룹화 한다. (GROUP BY)
4. 그룹핑된 값의 조건에 맞는 것만을 출력한다. (HAVING)
5. 데이터 값을 출력/계산한다. (SELECT)
6. 데이터를 정렬한다. (ORDER BY)

- 위 순서는 옵티마이저가 SQL 문장의 SYNTAX, SEMANTIC 에러를 점검하는 순서이기도 하다.
- 예를 들면 FROM 절에 정의되지 않은 테이블의 칼럼을 WHERE 절, GROUP BY 절, HAVING 절, SELECT 절, ORDER BY 절에서 사용하면 에러가 발생한다.

##### 조인(JOIN)이란

- 두 개 이상의 테이블 들을 연결 또는 결합하여 데이터를 출력하는 것을 JOIN이라고 한다.
- 일반적으로 사용되는 SQL 문장의 상당수가 JOIN이기에 매우 중요하다.
- 일반적인 경우 행들은 PRIMARY KEY(PK)나 FOREIGN KEY(FK) 값의 연관에 의해 JOIN이 성립된다.
- 하지만 어떤 경우에는 이러한 PK, FK의 관계가 없어도 논리적인 값들의 연관만으로 JOIN이 성립 가능하다.

##### JOIN의 주의점

- FROM 절에 여러 테이블이 나열되더라도 SQL에서 데이터를 처리할 때는 단 두 개의 집합 간에만 조인이 일어난다는 것이다.

##### JOIN의 종류

EQUI JOIN

- EQUI(등가) JOIN은 두 개의 테이블 간에 칼럼 값들이 서로 정확하게 일치하는 경우에 사용되는 방법으로 대부분 PK ↔ FK의 관계를 기반으로 한다. 그러나 일반적으로 테이블 설계 시에 나타난 PK ↔ FK의 관계를 이용하는 것이지 반드시 PK ↔ FK의 관계로만 EQUI JOIN이 성립하는 것은 아니다.
- 이 기능은 계층형(Hierarchical)이나 망형(Network) 데이터베이스와 비교해서 관계형 데이터베이스의 큰 장점이다.
- JOIN의 조건은 WHERE 절 에 기술하게 되는데 “=” 연산자를 사용해서 표현한다.

```sql
-- EQUI JOIN의 대략적인 형태
SELECT 테이블1.칼럼명, 테이블2.칼럼명, ... 
FROM 테이블1, 테이블2
WHERE 테이블1.칼럼명1 = 테이블2.칼럼명2;
-- WHERE 절에 JOIN 조건을 넣는다.
```

```sql
-- ANSI/ISO SQL 표준방식으로 표현한 EQUI JOIN
SELECT 테이블1.칼럼명, 테이블2.칼럼명, ...
FROM 테이블1 INNER JOIN 테이블2
ON 테이블1.칼럼명1 = 테이블2.칼럼명2;
-- → ON 절에 JOIN 조건을 넣는다.
```

##### Non EQUI JOIN

- Non EQUI(비등가) JOIN은 두 개의 테이블 간에 칼럼 값들이 서로 정확하게 일치하지 않는 경우에 사용된다.
- Non EQUI JOIN의 경우에는 “=” 연산자가 아닌 다른(Between, >, >=, <, <= 등) 연산자들을 사용하여 JOIN을 수행하는 것이다.

```sql
-- Non EQUI JOIN의 대략적인 형태
SELECT 테이블1.칼럼명, 테이블2.칼럼명, ...
FROM 테이블1, 테이블2
WHERE 테이블1.칼럼명1 BETWEEN 테이블2.칼럼명1 AND 테이블2.칼럼명2;
-- BETWEEN A AND B 조건은 Non EQUI JOIN의 사례
```

##### 3개 이상의 TABLE JOIN

```sql
-- [예제]
SELECT P.PLAYER_NAME 선수명, P.POSITION 포지션, T.REGION_NAME 연고지, T.TEAM_NAME 팀명, S.STADIUM_NAME 구장명
FROM PLAYER P, TEAM T, STADIUM S
WHERE P.TEAM_ID = T.TEAM_ID AND T.STADIUM_ID = S.STADIUM_ID
ORDER BY 선수명;
-- 또는 INNER JOIN을 명시하여 사용할 수도 있다.
SELECT P.PLAYER_NAME 선수명, P.POSITION 포지션, T.REGION_NAME 연고지, T.TEAM_NAME 팀명, S.STADIUM_NAME 구장명
FROM PLAYER P INNER JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID
INNER JOIN STADIUM S
ON T.STADIUM_ID = S.STADIUM_ID
ORDER BY 선수명;
```

##### JOIN이 필요한 이유

- JOIN이 필요한 기본적인 이유는 정규화에서부터 출발한다. 정규화란 불필요한 데이터의 정합성을 확보하고 이상현상(Anomaly) 발생을 피하기위해, 테이블을 분할하여 생성하는 것이다.