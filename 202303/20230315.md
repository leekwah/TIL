#### SQLD

##### 성능 데이터 모델링

- 성능은 데이터조회의 성능을 의미한다.
- 성능 데이터 모델링이란 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것이다.

##### 성능 데이터 모델링 수행시점

- 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무(Rework) 비용을 최소화 할 수 있는 기회를 가제 된다.
- 성능이 저하되는 SQL 문장을 튜닝하고, 부족한 하드웨어 용량(CPU, Memory 등)을 증설하는 등의 작업은 추가적인 비용을 소진하게 하는 원인이 된다. 특히 데이터의 증가가 빠를수록 성능저하에 따른 성능개선 비용은 기하급수적으로 증가하게 된다.
- 따라서, 분석/설계 단계에서 데이터베이스 처리 성능을 향상시킬 수 있는 방법을 주도면밀하게 고려해야 한다. 데이터 모델의 구조도 변경하면서 어떠한 구조가 해당 사이트에 성능상 가장 적절한 구조인지를 검토하여 성능이 좋은 모습으로 디자인하는 전략이 요구된다.

##### 성능 데이터 모델링 고려사항

1. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
2. 데이터베이스 용량산정을 수행한다.
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.
6. 성능관점에서 데이터 모델을 검증한다.

##### 정규화와 성능

- 정규화 수행 모델은 데이터를 입력/수정/삭제할 때 일반적으로 반정규화된 테이블에 비해 처리 성능이 향상된다.
- 단, 데이터를 조회할 때는 처리 조건에 따라 조회 성능이 향상될 수도 있고, 저하될 수도 있다.

##### 함수적 종속성(Functional Dependency)

- 함수의 종속성(Functional Dependency)은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다.
- 이 때, 기준값을 결정자(Determinant)라 하고, 종속되는 값을 종속자(Dependent)라고 한다.
- 종속자는 근본적으로 결정자에 함수적으로 종속성을 가지고 있다.

##### 함수적 종속성(Functional Dependency)과 정규화

- 기본적으로 데이터는 속성간의 함수종석성에 근거하여 정규화되어야 한다.
- 프로젝트 수행 시 정규화는 선택사항이 아닌 필수사항이다.

##### 반정규화(Denormalization)

- 반정규화(=역정규화)는 아예 정규화를 수행하지 않은 모델을 지칭할 때 사용한다.
- 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.
- 협의의 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있으며, 광의의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다.

##### 반정규화를 수행할 때

- 데이터를 조회할 때 디스크 I/O 량이 많아서 성능이 저하될 때
- 경로가 너무 멀어 조인으로 인한 성능 저하가 예상될 때
- 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상될 때
- 업무적으로 조회에 대한 처리성능이 중요하다고 판단될 때, 부분적으로 반정규화를 고려한다.
- 또한 정규화와의 함수적 종속관계는 위반하지 않지만 데이터의 중복성을 증가시켜야만 데이터조회의 성능을 향상시키는 경우, 반정규화를 통해 성능을 향상시킬 수 있게 된다.

##### 반정규화를 기술적으로 수행하지 않는 경우 발생하는 현상

- 성능이 저하된 데이터베이스가 생성될 수 있다.
- 구축단계나 시험단계에서 반정규화를 적용할 때 수정에 따른 노력비용이 많이 들게 된다.

##### 반정규화의 적용방법

1. 반정규화 대상조사 : 전체 데이터의 양을 조사하고 그 데이터가 해당 프로세스를 처리할 때 성능저하가 나타날 수 있는지 검증해야 한다. 데이터가 대량이고 성능이 저하될 것으로 예상되면 다음 4가지 경우를 고려하여 반정규화를 고려하게 된다.
   - 범위처리빈도수 조사 : 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우
   - 대량의 범위 처리 조사 : 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우, 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
   - 통계성 프로세스 조사 : 통계성 프로세스에 의해 통계 정보를 필요로 할 때
   - 테이블 조인 개수 : 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려운 경우
2. 다른 방법유도 검토 : 가급적이면 데이터를 중복하여 데이터 무결성을 깨뜨릴 위험을 제어하기 위해 반정규화 결정 이전에 성능을 향상시킬 수 있는 다른 방법을 모색한다.
   - 뷰(VIEW) 테이블 : 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰(VIEW)를 사용하면 해결할 수 있다.
   - 클러스터링 적용 : 인덱스를 통해 조정했음에도 성능향상이 불가능하면 클러스터링을 적용하는 방법으로 성능을 향상시킬 수 있다. 하지만, 조회중심의 테이블이 아니라면 생성하면 안되는 오브젝트이다.
   - 인덱스의 조정 : 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 인덱스를 조정함으로 성능을 향상시킬 수 있다.
   - 파티셔닝(Partitioning) 테이블 : 특정 기준에 의해 물리적인 저장공간이 구분될 수 있고 트랜잭션이 들어올 때 일정한 기준에 의해 들어온다면 파티셔닝 테이블을 적용하여 조회의 성능을 향상시킬 수 있다.
   - 응용애플리케이션 : 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.
3. 반정규화 적용 : 반정규화를 적용하기 이전에 충분히 성능에 대한 고려가 이루어져서 반정규화를 적용해야겠다는 판단이 들었다면, 반정규화의 세 가지 규칙을 고려하여 반정규화를 적용하도록 한다. 성능을 향상시킬 수 있는 포괄적인 방법을 적용하여 반적유화를 적용하는 것이 전문화된 반정규화의 기법임을 기억해야 한다.
   - [테이블 반정규화](##### 테이블 반정규화)
   - [속성 반정규화](##### 칼럼 반정규화(속성 반정규화))
   - [관계 반정규화](##### 관계 반정규화)

##### 테이블 반정규화

- 테이블병합
  - 1:1 관계 테이블병합 : 1:1 관계를 통합하여 성능을 향상시킨다.
  - 1:M 관계 테이블병합 : 1:M 관계를 통합하여 성능을 향상시킨다.
  - 슈퍼/서브타입 테이블병합 : 슈퍼/서브 관계를 통합하여 성능을 향상시킨다.
- 테이블 분할
  - 수직분할 : 칼럼단위의 테이블을 디스크 I/O를 분산처리 하기 위해 테이블을 1:1로 분리하여 성능을 향상시킨다.
  - 수평분할 : 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터접근의 효율성을 높여 성능을 향상시키기 위해 로우단위로 테이블을 쪼갠다.

- 테이블 추가

  - 중복테이블 추가 : 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상시킨다.

  - 통계테이블 추가 : SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상시킨다.
  - 이력테이블 추가 : 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 성능을 향상시킨다.
  - 부분테이블 추가 : 하나의 테이블은 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성해 성능을 향상시킨다.

##### 칼럼 반정규화(속성 반정규화)

- 중복칼럼 추가 : 조인에 의해 처리할 때, 중복된 칼럼을 위치시켜 조인을 감소시켜 성능을 향상시킨다.
- 파생칼럼 추가 : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 컬럼에 보관한다.이 때 보관하는 칼럼을 Derived Column이라고 한다.
- 이력테이블 칼럼추가 : 대량의 이력데이터를 처리할 때 불특정날 조회나 최근값을 조회할 때 나탈 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼을 추가하여 성능을 향상시킨다.
- PK에 의한 칼럼 추가 : 복합의미를 갖는 PK를 단일 속성으로 구성하였을 경우 발생된다. 단일 PK안에서 특정 값을 별도로 조회하는 경우 성능저하가 발생될 수 있다. 이 때 이미 PK안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법이 PK에 의한 칼럼추가 반정규화이다.
- 응용시스템 오작동을 위한 칼럼 추가 : 사용자의 실수로 원래 값으로 복구하기를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법이다.

##### 관계 반정규화

- 중복관계 추가 : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법이다.

##### 대량 데이터 발생에 따른 성능저하를 유발할 수 있는 경우

- 한 테이블에 데이터가 대량으로 집중될 때
- 하나의 테이블에 여러 개의 칼럼이 존재하여 디스크에 많은 블록을 점유할 때

- **로우체이닝(Row Chaining)**
  - 로우체이닝(Row Chaining) : 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태이다.
- **로우마이그레이션(Row Migration)**
  - 로우마이그레이션(Row Migration) : 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식이다.
- 트랜잭션을 분석하여 적절한 관계로 분리함으로써 디스크 I/O를 줄여 성능을 개선시킬 수 있다.

##### 대랑 데이터 저장 및 처리로 인해 성능저하를 유발할 수 있는 경우

- 데이터량이 몇 천만건을 넘어서면 아무리 좋은 하드웨어나 모델링을 했다고 해도, 성능이 잘 나오지 않는다. 이럴 때에는 파티셔닝을 적용하거나 PK에 의해 테이블을 분할하는 방법이 있다. Oracle의 경우 크게 LIST PARTITION, RANGE PARTITION, HASH PARTITION, COMPOSITE PARTITION이 가능하다.
- **RANGE PARTITION 적용**
  - 대상 테이블이 날짜 또는 숫자값으로 분리 가능하고, 각 영역별로 트랜잭션이 분리된다면 RANGE PARTITION을 적용할 수 있다.
- **LIST PARTITION 적용**
  - 지점, 사업소, 사업장, 핵심적인 코드값 등으로 PK가 구성되어 있고, 대량의 데이터가 있는 테이블이라면 값 각각에 의해 파티셔닝이 되는 LIST PARTITION을 적용할 수 있다.
- **HASH PARTITION 적용**
  - 기타 HASH PARTITION은 지정된 HASH 조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리되며 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다. 역시 성능향상을 위해 사용한다.

##### 테이블에 대한 수평분할/수직분할의 절차

1. 데이터 모델링을 완성한다.
2. 데이터베이스 용량산정을 한다.
3. 대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.

##### 테이블에 따른 테이블 분할 방법

- 특정 테이블의 용량이 대용량인 경우 칼럼의 수가 너무 많은지 확인한다. 칼럼의 수가 많은 경우 트랜잭션의 특성에 따라 테이블을 1:1 형태로 분리할 수 있는 지 검증하면 된다.
- 칼럼의 수가 적지만 데이터용량이 많아 성능저하가 예상되는 경우, 테이블에 대해 파티셔닝 전략을 고려하도록 한다. 이 때, 임의로 파티셔닝할 것인지 데이터가 발생되는 시간에 따라 파티셔닝을 할 것인지를 설명된 기준에 따라 적용하면 된다.

##### 슈퍼/서브타입 데이터 모델

- Extended ER 모델이라고 부르는 슈퍼/서브타입 데이터 모델은 논리적인 데이터 모델에서 이용되는 형태이고, 분석단계에서 많이 쓰이는 모델이다. 
- 업무를 구성하는 데이터의 특징을 공통점과 차이점의 특징을 고려하여 효과적으로 표현할 수 있기 때문에 최근 데이터 모델링 설계시 자주 활용된다.
- 공통의 부분을 슈퍼타입으로 모델링하고, 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브엔터티로 구분하여 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환을 할 때, 선택의 폭을 넓힐 수 있는 장점이 있다.

##### 잘못된 슈퍼/서브타입 변환으로 성능이 저하되는 경우

- 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하되는 경우
- 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하되는 경우
- 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리한느데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하되는 경우

##### 슈퍼/서브 타입 데이터 모델의 변환기술

1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성 (OneToOne Type)
2. 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성 (Plus Type)
3. 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성 (Single Type)

##### 슈퍼/서브타입 데이터 모델의 변환타입 비교

| 구분                           | OneToOne Type                       | Plus Type                                      | Single Type                          |
| ------------------------------ | ----------------------------------- | ---------------------------------------------- | ------------------------------------ |
|                                | 개별 테이블 유지                    | 슈퍼+서브타입 테이블                           | 하나의 테이블                        |
| 확장성                         | 우수함                              | 보통                                           | 나쁨                                 |
| 조인성능                       | 나쁨                                | 나쁨                                           | 우수함                               |
| I/O량 성능                     | 좋음                                | 좋음                                           | 나쁨                                 |
| 관리용이성                     | 좋지 않음                           | 좋지 않음                                      | 좋음(1개)                            |
| 트랜잭션 유형에 따른 선택 방법 | 개별 테이블로 접근이 많은 경우 선택 | 슈퍼+서브 형식으로 데이터를 처리하는 경우 선택 | 전체를 일괄적으로 처리하는 경우 선택 |

**인덱스 특성을 고려한** **PK/FK DB** **성능향상**

- 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때. 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 효율을 나타낸다.
- 즉, 앞쪽에 위치한 속성의 값이 가급적 ‘=’ 아니면 최소한 범위 ‘BETWEEN’ ‘<>’ 가 들어와야 효율적이다.

##### 분산 데이터베이스의 정의

- 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스이다.
- 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임이다.
- 즉, 분산 데이터베이스는 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 사용성/성능 등을 극대화 시킨 데이터베이스라고 정의할 수 있다.

##### 분산 데이터베이스를 만족하기 위한 6가지 투명성(Transparency)

1. 분할 투명성 (단편화) : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 Site에 저장되어야 한다.
2. 위치 투명성 : 사용하려는 데이터의 저장 장소 명시가 불필요하다.
3. 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 Mapping을 보장해야한다.
4. 중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질이어야 한다.
5. 장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 Transaction의 원자성을 유지해야 한다.
6. 병행 투명성 : 다수 Transaction 동시 수행 시 결과의 일관성이 유지, Time Stamp, 분산 2단계 Locking을 이용해 구현되어야 한다.

##### 분산 데이터베이스 장단점

| 장점                                                         | 단점                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| - 지역 자치성, 점증적 시스템 용량 확장<br />- 신뢰성과 가용성<br />- 효용성과 융통성<br />- 빠른 응답 속도와 통신비용 절감<br />- 데이터의 가용성과 신뢰성 증가<br />- 시스템 규모의 적절한 조절<br />- 각 지역 사용자의 요구 수용 증대 | - 소프트웨어 개발 비용<br />- 오류의 잠재성 증대<br />- 처리 비용의 증대<br />- 설계, 관리의 복잡성과 비용<br />- 불규칙한 응답 속도<br />- 통제의 어려움<br />- 데이터 무결성에 대한 위협 |

##### 분산 데이터베이스의 적용 기법

- 테이블 위치 분산
  - 지역별 분산 : 설계된 테이블의 위치를 각각 다르게 위치시키는 것이다. 정보를 이용하는 형태가 각 위치별로 차이가 있을 경우에 이용한다. 테이블의 위치가 위치별로 다르므로 테이블의 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서가 필요하다.
- 테이블 분할 분산
  - 수평분할(Horizontal Fragmentation) : 테이블의 로우(Row)단위로 분리하는 방법이다. 지사(Node)별로 사용하는 로우(Row)가 다를 때 이용한다. 지사(Node)에 따라 테이블을 특정 칼럼의 값을 기준으로 분리한다. 칼럼은 분리되지 않으며, 각 지사에 있는 데이터와 다른 지사에 있는 데이터는 항상 배타적으로 존재하며 한 군데 집합시켜도 Primary Key에 의해 중복이 발생하지 않는다.
  - 수직분할(Vertical Fragmentation) : 테이블을 칼럼(Column)단위로 분할하는 방법이다. 지사(Node)에 따라 테이블 칼럼을 기준으로 칼럼(Column)을 분리한다. 칼럼을 기준으로 분할하였기 때문에 각각의 테이블에는 동일한 Primary Key 구조와 값을 가지고 있어야 한다. 지사별로 쪼개진 테이블들을 조합하면 Primary Key가 동일한 데이터의 조합이 가능해야 하며, 하나의 완전한 테이블이 구성되어야 한다. 데이터를 한 군데 집합시켜 놓아도 동일한 Primary Key는 하나로 표현하면 되므로, 데이터 중복은 발생되지 않는다.
- 테이블 복제 분산
  - 부분 복제(Segment Replication) : 통합된 테이블을 한 군데(본사)에 가지고 있으면서 각 지사별로는 지사에 해당된 로우(Row)를 가지고 있는 형태이다. 지사에 존재하는 데이터는 반드시 본사에 존재하게 된다. 즉, 본사의 데이터는 지사 데이터의 합이 되는 것이다. 본사와 지사 양쪽 모두 데이터를 수정하여 전송하는 경우, 데이터의 정합성을 일치시키는 것이 어렵기 때문에, 가능하면 한 쪽(지사)에서 데이터의 수정이 발생하여 본사로 복제(Replication)를 하도록 한다.
  - 광역 복제(Broadcast Replication) : 통합된 테이블을 한 군데(본사)에 가지고 있으면서 각 지사에도 본사와 동일한 데이터를 모두 가지고 있는 형태이다. 지사에 존재하는 데이터는 반드시 본사에 존재하게 된다. 모든 지사에 있는 데이터량과 본사에 있는 데이터량이 다 동일하다. 본사와 지사 모두 동일한 정보를 가지고 있으므로, 본사나 지사나 데이터처리에 특별한 제약을 받지는 않는다. 데이터를 복제하는데 많은 시간이 소요되고, 데이터베이스와 서버에 부하가 발생하므로 보통 실시간 처리에 의해 복사하는 것보다 배치에 읳해 복제되도록 한다.
- 테이블 요약 분산
  - 분석 요약(Rollup Replication) : 각 지사별로 존재하는 요약정보를 본사에 통합하여 다시 전체에서 요약정보를 산출하는 분산방법이다.
  - 통합 요약(Consolidation Replication) : 각 지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법이다.

##### 데이터베이스 분산 설계를 효과적으로 적용하는 방법

- 성능이 중요한 사이트에 적용해야 한다.
- 공통코드, 기준정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능이 좋아진다.
- 실시간 동기화가 요구되지 않을 때 좋다.
- 거의 실시간(Near Real Time)의 업무적인 특징을 가지고 있을 때도 분산 환경을 구성할 수 있다.
- 특정 서버에 부하가 집중이 될 때, 부하를 분산할 때도 좋다.
- 백업 사이트(Disaster Recovery Site)를 구성할 때, 간단하게 분산기능을 적용하여 구성할 수 있다.

































