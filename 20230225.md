##### 프로그램의 오류

- 컴파일 에러(comile-time error) : 컴파일 할 때 발생하는 에러
- 런타임 에러(runtime error) : 실행할 때 발생하는 에러
  - 에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
  - 예외(exception) : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
- 논리적 에러(logical error) : 작성 의도와 다르게 동작

##### 예외처리(exception handling)의 정의와 목적

- 예외처리의 정의 : 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것
- 예외처리의 목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것

##### Exception과 RuntimeException

- Exception 클래스와 자손 클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
- RuntimeException 클래스와 자손 클래스들 : 프로그래머의 실수로 발생하는 예외

##### try-catch문으로 예외 처리하기

- try 블럭 내에서 예외가 발생한 경우
  - 1. 발생한 예외와 일치하는 catch 블럭이 있는지 확인한다.
    2. 일치하는 catch 블럭을 찾게 되면, 그 catch 블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch 블럭을 찾지 못하면, 예외는 처리되지 못한다.
- try 블럭 내에서 예외가 발생하지 않은 경우
  - catch 블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.

##### 예외의 발생과 catch 블럭

- 예외가 발생하면, 이를 처리할 catch 블럭을 찾아 내려간다.
- 일치하는 catch 블럭이 없다면, 예외는 처리되지 않는다.
- Exception이 선언된 catch 블럭은 모든 예외 처리를 수행한다. (마지막 catch 블럭 - 모든 예외의 최고 조상이기 때문이다.)

##### printStackTrace()와 getMessage()

- 예외 발생시, ArithmeticException 클래스에서 예외 객체가 생성된다. 객체 내에 발생한 예외에 대한 정보가 적혀있으며, printStackTrace(), getMessage()와 같은 메서드들이 존재한다.
- printStackTrace() : 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
- getMessage() : 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

##### 멀티 catch 블럭

- 내용이 같은 catch 블럭을 하나로 합치는 것 (코드의 중복을 제거하기 위해서 '|' 를 사용한다.)
- 주의할 점은 멀티 catch 블럭에 쓰는 클래스가 부모-자식 클래스는 사용하지 않고 부모 클래스의 예외만 선언한다.
- 하나의 catch 블럭으로 여러 예외를 처리하는 것이기 때문에, 멀티 catch객체를 선언시에는 참조변수는 공통된 멤버만 사용가능하다.
- 만약에 쓰고 싶다면 if-else 문으로 형변환을 해서 호출해야한다.

##### 예외 발생시키기

- 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음 키워드 throw를 이용해서 예외를 발생시킨다.
- 객체를 만든 것만으로는 예외가 발생하지 않으며, throw를 이용해야지 예외가 발생된다.

##### checked 예외, unchecked 예외

- checked 예외 : 컴파일러가 예외 처리 여부를 체크(예외 처리 필수, Exception과 자손)
- unchecked 예외 : 컴파일러가 예외 처리 예부를 체크하지 않음(예외 처리 선택, RuntimeException과 자손)