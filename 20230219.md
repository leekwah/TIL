##### Java의 기본 자료형

- 문자
  - char(2btye)
- 정수
  - byte(1btye)
  - short(2btye)
  - int(4btye)
  - long(4btye)
- 실수
  - float(4btye)
  - double(8btye)
- 논리
  - boolean(1btye)

##### UNIX 시스템의 구성

- 커널(Kernel)
  - UNIX의 가장 핵심적인 부분이다.
  -  컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행된다.
  - 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다.
  - 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입 ・ 출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행한다.
- 쉘(Shell)
  - 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
  - 시스템과 사용자 간의 인터페이스를 담당한다.
  - DOS의 COMMAND.COM과 같은 기능을 수행한다.
  - 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능하다.
  - 파이프라인 기능을 지원하고 입 ・ 출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다.
  - 공용 Shell(Bourne Shell, C Shell, Korn Shell)이나 사용자 자신이 만든 Shell을 사용할 수 있다.
- 유틸리티(Utility Program)
  - 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용한다.
  - DOS에서의 외부 명령어에 해당된다.
  - 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다.

##### 재사용(Reuse)

- 재사용은 비용과 개발 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업이다.
- 재사용을 위해서는 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야한다.
- 재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야 한다.

##### 재사용 규모에 따른 분류

| 규모         | 분류                                                         |
| ------------ | ------------------------------------------------------------ |
| 함수와 객체  | 클래스나 메소드 단위의 소스 코드를 재사용함                  |
| 컴포넌트     | 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함 |
| 애플리케이션 | 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용함 |

##### 비선점(Non-preemptive) 스케줄링

이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법이다.

##### 비선점 스케줄링의 종류

- FCFS(First Come First Service, 선입 선출) = FIFO(First In First Out)
  - 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법으로, 가장 간단한 알고리즘
- SJF(Shortest Job First, 단기 작업 우선)
  - 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
- HRN(Highest Response-ratio Next)
  - 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행) 시간을 이용하는 기법
  - 우선순위 계산식 : (대기시간 + 서비스시간) / 서비스 시간
- 기한부(Deadline)
  - 프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법
- 우선순위(Priority)
  - 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법

##### 흐름제어

- 네트워크 내의 원활한 흐름을 위해 송 ・ 수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능이다.
- 송신 측과 수슨 측 간의 처리 속도 또는 버퍼 크기의 차이에 의해 생길 수 있는 수신 측 버퍼의 오버플로(Overflow)를 방지하기 위한 기능이다.
- 정지-대기(Stop-and-Wait)
  - 수신 측의 확인 신호(ACK)를 받은 후에 다음 패킷을 전송하는 방식이다.
  - 한 번에 하나의 패킷만을 전송할 수 있다.
- 슬라이딩 윈도우(Sliding Window)
  - 확인 신호, 즉 수신 통지를 이용하여 송신 데이터의 양을 조절하는 방식이다.
  - 수신 측의 확인 신호를 받지 않더라도 미리 정해진 패킷의 수만큼 연속적으로 전송하는 방식으로, 한 번에 여러 개의 패킷을 전송할 수 있어 전송 효율이 좋다.
  - 송신 측은 수신 측으로부터 확인신호(ACK) 없이도 보낼 수 있는 패킷의 최대치를 미리 약속 받는데, 이 패킷의 최대치가 윈도우 크기(Window Size)를 의미한다.
  - 윈도우 크기(Window Size)는 상황에 따라 변한다. 즉, 수신 측으로부터 이전에 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신 측으로부터 이전에 송신한 패킷에 대해 부정 수신 응답(NAK)이 전달된 경우 윈도우 크기는 감소한다.

##### UPD(User Datagram Protocol)

- 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공한다.
- TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로, 오버헤드가 적다.
- 고속의 안전성 있는 전송 매체를 사용하여 빠른 속도를 필요로 하는 경우, 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우에 사용한다.
- 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요시되는 네트워크에서 사용된다.
- UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 포함된다.

##### PHP 연산자

| 연산자 기호 | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| @           | 오류 메시지를 숨겨주는 오류 제어 연산자                      |
| <>          | 같지 않음을 의미하는 관계 연산자                             |
| ===         | 두 인자 값과 형식이 모두 일치하는지 비교할 때 사용하는 관계 연산자 |

##### CMM(Capability Maturity Model)

- 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델로, 미국 카네기멜론 대학교의 소프트웨어 공학연구소(SEI)에서 개발하였다.
- CMM의 소프트웨어 프로세스 성숙도는 초기, 관리, 정의, 정량적 관리, 최적화의 5단계로 구분한다.

| 단계                                | 프로세스             | 특징                                             |
| ----------------------------------- | -------------------- | ------------------------------------------------ |
| 초기(Initial)                       | 정의된 프로세스 없음 | 작업자 능력에 따라 성공 여부 결정                |
| 관리(Managed)                       | 규칙화된 프로세스    | 특정한 프로젝트 내의 프로세스 정의 및 수행       |
| 정의(Defined)                       | 표준화된 프로세스    | 조직의 표준 프로세스를 활용하여 업무 수행        |
| 정량적 관리(Quantitatively Managed) | 예측 가능한 프로세스 | 프로젝트를 정량적으로 관리 및 통제               |
| 최적화(Optimizing)                  | 지속적 개선 프로세스 | 프로세스 역량 향상을 위해 지속적인 프로세스 개선 |

##### 접근통제

- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다.
- 접근 통제는 데이터에 대해 다음과 같은 통제를 함으로써 자원의 불법적인 접근 및 파괴를 예방한다.

##### 정보통제의 3요소

- 접근통제 정책
- 접근통제 매커니즘
- 접근통제 보안모델

##### 접근통제 기술

- 임의 접근통제(DAC, Discreionary Access Control) : 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
- 강제 접근통제(MAC, Manadtory Access Control) : 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
- 역할기반 접근통제(RBAC, Role Based Access Control) : 사용자의 역할에 따라 접근 권한을 부여하는 방식

##### 수학적 비용 산정 기법

- COCOMO 모형 : 원시 프로그램의 규모인 LOC(원시 코드 라인 수)에 의한 비용 산정 기법으로, 보헴(Bohem)이 제안하였으며, 개발할 소프트웨어의 규모(LOC)를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정함
- 기능점수(FP, Function Point) 모형 : 알프레히트(Albrecht)가 제안한 것으로, 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능 점수를 산출하며, 총 기능 점수와 영향도를 이용하여 기능 점수(FP)를 구한 후 이를 이용해서 비용을 산정하는 기법
- Putnam 모형 : 소프트웨어 생명 주기의 전 과정 동안에 상용될 노력의 분포를 가정해 주는 모형으로, 푸트남(Putnam)이 제안한 것으로 생명 주기 예측 모형이라고도 함

##### 공개키 암호화(Public Key Encryption) 기법

- 공개키 암호화 기법은 데이터를 암호화할 때 사용하는 공개키(Public Key)는 데이터베이스 사용자에게 공개하고, 복호화할 때의 비밀키(Secret Key)는 관리자가 비밀리에 관리한다.
- 공개키 암호화 기법은 비대칭 암호 기법이라고도 하며, 대표적으로는 RSA(Rivvest Shamir Adleman) 기법이 있다.
- 장점
  - 키의 분배가 용이함
  - 관리해야 할 키의 개수가 적음
- 단점
  - 암호화/복호화 속도가 느림
  - 알고리즘이 복잡함
  - 개인키 암호화 기법보다 파일 크기가 큼

##### SPICE(Software Process Improvement and Capability dEtermination)

- SPICE(소프트웨어 처리 개선 및 능력 평가 기준)는 정보 시스템 분야에서 소프트웨어의 품질 및 생생선 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준으로, 공식 명칭은 ISO/IEC 15504이다.
- SPICE의 목적
  - 프로세스 개선을 위해 개발 기관이 스스로 평가하는 것
  - 기관에서 지정한 요구조건의 만족여부를 개발 조직이 스스로 평가하는 것
  - 계약 체결을 위해 수탁 기관의 프로세스를 평가하는 것
- SPICE는 5개의 프로세스 범주와 40개의 세부 프로세스로 구성된다.
- SPICE는 프로세스 수행 능력 단계를 불완전, 수행, 관리, 확립, 예측, 최적화의 6단계로 구분한다.