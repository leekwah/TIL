##### 결합도(Coupling)

- 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다.
- 다양한 결합으로 모듈을 구성할 수 있으나 결합도가 약할 수록 품질이 높고, 강할수록 품질이 낮다.
- 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.
- 결합도의 종류(약함에서 강함순)
  - 자료 결합도(Data Coupling) : 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
  - 스탬프(검인) 결합도(Stamp Coupling) : 모듈 간의 인터페이스로 배열이나 레코드 드으이 자료 구조가 전달될 때의 결합도
  - 제어 결합도(Control Coupling) : 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
  - 외부 결합도(External Coupling) : 어떤 모듈에서 외부로 선언한 데이터(변수)를 다른 모듈에서 참조할 때의 결합도
  - 공통(공유) 결합도(Common Coupling) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
  - 내용 결합도(Content Coupling) : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도로 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당됨

##### XP(eXtreme Programing)

- XP는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.
- XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.
- 릴리즈 테스트마다 고객을 직접 참여시킴으로써 요구한 기능이 제대로 작동하는지 고객이 직접 확인할 수 있다.
- 비교적 소규모 인원의 개발 프로젝트에 효과적이다.

##### XP의 5가지 핵심 가치

- 의사소통(Communication)
- 단순성(Simplicity)
- 용기(Courage)
- 존중(Respect)
- 피드백(Feedback)

##### 주요 아키텍쳐 패턴(Patterns)의 종류

- 레이어 패턴(Layers Pattern) : 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 중의 하나로 각각의 서브시스템들이 계층 구조를 이루며, 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 됨
- 클라이언트-서버 패턴(Client-Server Pattern) : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴으로, 클라이언트가 서버에 요청하고 응답을 받아 사용자에게 제공하는 방식
- (Pipe-Filter Pattern) : 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
- (Model-View-Controller Pattern) : 서브시스템을 모델(Model), 뷰(View), 컨트롤러(Controller)의 세 부분으로 구조화하는 패턴

##### 사용자 인터페이스의 종류

- CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphic User Interface) : 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
- VUI(Voice User Interface) : 사람의 음성으로 기기를 조작하는 인터페이스
- OUI(Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

##### 순차 다이어그램의 구성 요소

- 액터(Actor) : 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함
- 객체(Object) : 메시지를 주고받는 주체
- 라이프라인(Lifeline) : 객체가 메모리에 존재하는 기간
- 활성(실행) 상자(Activation Box) : 객체가 메시지를 주고받으며 구동(실행)되고 있음을 표현
- 메시지(Message) : 객체가 상호 작용을 위해 주고받는 메시지

##### 미들웨어(Middleware)의 종류

- DB(Database) : 데이터베이스 벤더(Vendor)에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
- RPC(Remote Procedure Call) : 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미들웨어
- MOM(Message Oriented Middleware) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
- TP-Monitor(Transaction Processing Monitor) : 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어
- ORB(Object Request Broker) : 객체지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
- WAS(Web Application Server) : 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어

##### 블랙박스 테스트(Black Box Test)

- 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트로, <u>기능 테스트</u>라고도 한다.
- <u>프로그램의 구조를 고려하지 않기 때문에</u> 테스트 케이스는 <u>프로그램 또는 모듈의 요구나 명세를 기초로 결정</u>한다.
- 소프트웨어 인터페이스에서 실시되는 테스트이다.
- 부정확하거나 누락된 기능, 인터페이스 오류, 자료 구조나 외부 데이터베이스 접근에 따른 오류, 행위나 성능 오류, 초기화와 종료 오류 등을 발견하기 위해 사용되며, <u>테스트 과정의 후반부에 적용된다.</u>
- 블랙박스 테스트의 종류
  - 동치 분할 검사
  - 경계값 분석
  - 원인-효과 그래프 검사
  - 오류 예측 검사
  - 비교 검사 등

##### 화이트박스 테스트(White Box Test)

- 모듈의 원시코드를 오픈시킨 상태에서 <u>원시 코드의 논리적인 모든 경로를 테스트</u>하여 테스트 케이스를 설계하는 방법이다.
- <u>설계된 절차에 초점을 둔 구조적 테스트</u>로 프로시저 설계의 제어 구조를 사용하여 테스트 케이스를 설계하며, <u>테스트 과정의 초기에 적용된다.</u>
- 모듈 안의 작동을 직접 관찰한다.
- 원시 코드(모듈)의 <u>모든 문장을 한 번 이상 실행함</u>으로써 수행된다.
- 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어한다.
- 화이트박스 테스트의 종류
  - 기초 경로 검사
  - 제어 구조 검사(조건 검사, 루프 검사, 데이터 흐름 검사) 등

##### 형상 관리(SCM : Software Configuration Management)

- 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동이다.
- 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보한다.
- 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행된다.
- 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.
- 관리 항목에는 소스 코드 뿐만 아니라 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 등이 포함된다.
- 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.
- 대표적인 형상 관리 도구에는 Git, CVS, Subversion 등이 있다.

##### 형상 관리 기능

- 형상 식별 : 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
- 버전 제어 : 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차나 도구(Tool)를 결합시키는 작업
- 형상 통제(변경 관리) : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업
- 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- 형상 기록(상태 보고) : 형상의 식별, 통제, 감사 작업의 결과를 기록 ・ 관리하고 보고서를 작성하는 작업

##### EAI의 구축 유형

- Point-to-Point : 가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1:1로 연결하며 변경 및 재사용이 어려움
- Hub & Spoke : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식으로, 확장 및 유지 보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향을 미침
- Message Bus(ESB 방식) : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식으로, 확장성이 뛰어나며 대용량 처리가 가능함
- Hybrid : Hub & Spoke와 Message Bus의 혼합 방식으로, 그룹 내에서는 Hub & Spoke 방식을, 그룹 간에는 Message Bus 방식을 사용함

##### 테스트 오라클의 종류

- 참(True) 오라클 : <u>모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클</u>로, 발생된 모든 오류를 검출할 수 있음
- 샘플링(Sampling) 오라클 : <u>특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공</u>하는 오라클
- 추정(Heuristic) 오라클 : <u>샘플링 오라클을 개선</u>한 오라클로, 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, <u>나머지 입력 값들에 대해서는 추정으로 처리</u>하는 오라클
- 일관성 검사(Consistent) 오라클 : <u>애플리케이션의 변경이 있을 때,</u> 테스트 케이스의 <u>수행 전과 후의 결과 값이 동일한지를 확인</u>하는 오라클

##### 해싱 함수(Hashing Function)

- 제산법(Division) : 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식, 즉 h(K) = K mod Q 임
- 제곱법(Mid-Square) : 레코드 키 값(K)을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼는 방식
- 폴딩법(Folding) : 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
- 기수 변환법(Radix) : 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
- 대수적 코딩법(Algebraic Coding) : 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
- 계수 분석법(Digit Analysis, 숫자분석법) : 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
- 무작위법(Random) : 난수(Random Number)를 발생시켜 나온 값을 홈 주소로 삼는 방식

##### 인터페이스 구현 검증 도구

- xUnit : Java(Junit), C++(Cppunit), .Net(Nunit), Http(HttpUnit) 등 ㄷ양한 언어를 지원하는 단위 테스트 프레임워크
- STAF : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
- NTAF : FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
- Selenum : 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
- watir : Ruby를 사용하는 애플리케이션 테스트 프레임워크

##### 테스트 드라이버와 테스트 스텁

| 구분       | 드라이버(Driver)                                             | 스텁(Stub)                                                   |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 개념       | 테스트 대상의 하위 모듈을 호출하는 도구로, 매개 변수(Parameter)를 전달하고, 모듈 테스트 수행 후의 결과를 도출함 | 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 ㅍ필요한 조건만을 가지고 있는 시험용 모듈 |
| 필요시기   | 상위 모듈 없이 <u>하위 모듈이 있는 경우 하위 모듈 구동</u>   | 상위 모듈은 있지만 <u>하위 모듈이 없는 경우 하위 모듈 대체</u> |
| 테스트방식 | 상향식(Bottom Up)테스트                                      | 하향식(Top-Down) 테스트                                      |
| 공통점     | 소프트웨어 개발과 테스트를 병행할 경우 이용                  |                                                              |
| 차이점     | - 이미 존재하는 하위 모듈과 존재하지 않는 상위 모듈 간의 인터페이스 역할을 함<br />- 소프트웨어 개발이 완료되면 드라이버는 본래의 모듈로 교체됨 | - 일시적으로 필요한 조건만을 가지고 임시로 제공되는 가짜 모듈의 역할을 함<br />- 시험용 모듈이기 때문에 일반적으로 드라이버보다 작성하기 쉬움 |

##### 연결 리스트(Linked List)

- 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드(Node)의 포인터 부분을 이용하여 서로 연결시킨 자료 구조이다.
- 연결 리스트는 노드의 삽입 ・ 삭제 작업이 용이하다.
- 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다.
- 연결 리스트는 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다.
- 연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
- 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

##### 빅오 표기법(Big-O Notation)

알고리즘의 실행시간이 최악일 때를 표기하는 방법으로, 신뢰성이 떨어지는 오메가 표기법이나 평가하기 까다로운 세타 표기법에 비해 성능을 예측하기 용이하여 주로 사용되는 표기법이다.

| 표기                 | 내용                                                         |
| -------------------- | ------------------------------------------------------------ |
| O(1)                 | 입력값(n)에 관계 없이 일정하게 문제 해결에 하나의 단계만을 거침<br />ex) 스택의 삽입(Push), 삭제(Pop) |
| O(log<sub>2</sub>n)  | 문제 해결에 필요한 단계가 입력값(n) 또는 조건에 의해 감소함<br />ex) 이진 트리(Binary Tree), 이진 검색(Binary Search) |
| O(n)                 | 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 가짐<br />ex) for문 |
| O(nlog<sub>2</sub>n) | 문제 해결에 필요한 단계가 nlog<sub>2</sub>n번 만큼 수행됨<br />ex) 힙 정렬(Heap Sort), 2-Way 합병 정렬(Merge Sort) |
| O(n<sup>2</sup>)     | 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행됨<br />ex) 삽입 정렬(Insertion Sort), 쉘 정렬(Shell Sort), 선택 정렬(Selectin Sort), 버블 정렬(Bubble Sort), 퀵 정렬(Quick Sort) |
| O(2<sup>n</sup>)     | 문제 해결에 필요한 단계가 2의 입력값(n) 제곱만큼 수행됨<br />ex) 피보나치 수열(Fibonacci Sequence) |

##### 키

데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성이다.

- 슈퍼키(Super Key) : <u>한 릴레이션 내에 있는 속성들의 집합으로 구성된 키</u>로, 릴레이션을 구성하는 모든 튜플에 대해 <u>유일성(Unique)은 만족하지만, 최소성(Minimality)은 만족하지 못함</u>
- 후보키(Candidate Key) : 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, <u>유일성과 최소성을 모두 만족함</u>
- 기본키(Primary Key) : 후보키 중에서 특별히 선정된 키로 <u>중복된 값과 NULL 값을 가질 수 없음</u>
- 대체키(Alternate Key) : 후보키 중에서 선정된 <u>기본키를 제외한 나버지 후보키</u>를 의미함
- 외래키(Foreign Key) : <u>다른 릴레이션의 기본키</u>를 참조하는 속성 또는 속성들의 집합을 의미하며, <u>릴레이션 간의 관계를 표현할 때 사용함</u>