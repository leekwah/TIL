##### NewArithmeticOperator.interface

```java
public interface NewArithmeticOperator {
    boolean supports(String operator);
    int calculate(int operand1, int operand2);
}
```

##### AdditionOperator.java

```java
public class AdditionOperator implements NewArithmeticOperator {
    @Override
    public boolean supports(String operator) {
        return "+".equals(operator);
    }

    @Override
    public int calculate(int operand1, int operand2) {
        return operand1 + operand2;
    }
}
```

##### SubtractionOperator.java

```java
public class SubtractionOperator implements NewArithmeticOperator {
    @Override
    public boolean supports(String operator) {
        return "-".equals(operator);
    }

    @Override
    public int calculate(int operand1, int operand2) {
        return operand1 - operand2;
    }
}
```

##### MultiplicationOperator.java

```java
public class MultiplicationOperator implements NewArithmeticOperator {
  	@Override
    public boolean supports(String operator) {
        return "*".equals(operator);
    }

    @Override
    public int calculate(int operand1, int operand2) {
        return operand1 * operand2;
    }
}
```

##### DivisionOperator.java

```java
public class DivisionOperator implements NewArithmeticOperator {
  	@Override
    public boolean supports(String operator) {
        return "/".equals(operator);
    }

    @Override
    public int calculate(int operand1, int operand2) {
        return operand1 / operand2;
    }
}
```

Calculate.java

```java
import org.example.calculate.*;

import java.util.List;

public class Calculator {

    private final static List<NewArithmeticOperator> arithmeticOperators = List.of(new AdditionOperator(), new SubtractionOperator(), new MultiplicationOperator(), new DivisionOperator());
    public static int calculate(int operand1, String operator, int operand2) {
        return arithmeticOperators.stream()
                .filter(arithmeticOperators -> arithmeticOperators.supports(operator))
                .map(arithmeticOperators -> arithmeticOperators.calculate(operand1, operand2))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("올바른 사칙연산이 아닙니다.")); 
    }
}

```

- 인터페이스를 하나 두고, 인터페이스를 구현한 네개의 구현체를 인터페이스로 받고, 들어온 오퍼레이터에 맞는 구현체를 찾은 다음에 그 구현체에게 calculate() 라는 작업을 위임한다.
  해당하는 연산에 해당하는 구현체가 없다면, IllegalArgumentException이 발생한다.
