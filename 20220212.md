##### 클래스(Class)

- 클래스는 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입(Type)을 의미한다.
- 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
- 클래스는 객체지향 프로그램에서 데이터를 추상화하는 단위이다.
- ﻿﻿클래스에 속한 각각의 객체를 인스턴스(nstance)라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 한다.
- ﻿﻿동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타내게 된다.
- ﻿﻿최상위 클래스는 상위 클래스를 갖지 않는 클래스를 의미한다.
- 슈퍼 클래스(Super Class)는 특정 클래스의 상위(부모) 클래스이고, 서브 클래스 (Sub Class)는 특정 클래스의 하위(자식) 클래스를 의미한다.



##### 객체지향 설계 원칙

시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 5가지 원칙으로, 다섯 가지 원칙의 앞 글자를 따 SOLID 원칙이라고도 불린다.

- 단일 책임 원칙(SRP : Single Responsibiliy Principle)
  - 객체는 단 하나의 책임만 가져야 한다는 원칙이다.
  - 응집도는 높고, 결합도는 낮게 설계하는 것을 의미한다.
- 개방-폐쇄 원칙(OCP : Open-Close Principle)
  - 기존의 코드를 변경하지 않고, 기능을 추가할 수 있도록 설계해야 한다는 원칙이다.
  - 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는  방법이 대표적이다.
- 리스코프 치환 원칙(LSP : Liskov Substitution Principle)
  - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙이다.
  - 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.
- 인터페이스 분리 원칙(ISP : Interface Segregation Principle)
  - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야한다는 원칙이다.
  - 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임이다.
- 의존 역전 원칙(DIP : Dependency Inversion Principle)
  - 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙이다.
  - 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다.



##### 객체지향 분석의 방법론

- Rumbaugh(럼바우) 방법 : 가장 일반적으로 사용되는 방법으로, 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법
- Booch(부치) 방법 : 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함
- Jacobson 방법 : Use Case를 강조하여 사용하는 분석방법
- Coad Yourdon 방법 : E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
- Wires-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법



##### 디자인 패턴(Design Pattern)

- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
- 디자인 패턴은 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.
- '바퀴를 다시 발명하지마라(Don't reinvent the wheel)'라는 말과 같이, 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.
- 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있다.
- 1995년 GoF(Gang of Four)라고 불리는 에릭 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vlissides)가 처음으로 구체화 및 체계화하였다.
- GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴이다.
- GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.



##### 디자인 패턴의 종류

- 생성 패턴(Creational Pattern)
  - 추상 팩토리(Abstract Factory)
  - 빌더(Builder)
  - 팩토리 메소드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조 패턴(Structual Pattern)
  - 어댑터(Adapter)
  - 브리지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 퍼싸드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위 패턴(Behavioral Pattern)
  - 커맨드(Command)
  - 책임 연쇄(Chain of Responsibility)
  - 인터프리터(Interpreter)
  - 반복자(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵서버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿 메소드(Template Method)
  - 방문자(Visitor)



##### 클린 코드 작성 원칙

| 특성          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 가독성        | - ﻿﻿누구든지 코드를 쉽게 읽을 수 있도록 작성함<br />- 코드 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용함 |
| 단순성        | - 코드를 간단하게 작성함<br />- 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리함 |
| 의존성 배제   | - 코드가 다른 모듈에 미치는 영향을 최소화함<br />- 코드 변경시 다른 부분에 영향이 없도록 작성함 |
| 중복성 최소화 | - 코드의 중복을 최소화함<br />- 중복된 코드는 삭제하고 공통된 코드를 사용함 |
| 추상화        | - 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현함 |



##### 테스트 하네스(Test Harness)의 구성요소

- 테스트 드라이버(Test Driver) : 테스트 대상의 하위 모듈을 호출하고, 매개 변수(Parameter)를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구
- 테스트 스텁(Test Stub) : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
- 테스트 슈트(Test Suites) : 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
- 테스트 케이스(Test Case) : 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목의 명세서
- 테스트 스크립트(Test Script) : 자동화된 테스트 실행 절차에 대한 명세서
- 목 오브젝트(Mock Object) : 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체



##### 스택(Stack)

- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO : Last In First Out) 방식으로 자료를 처리한다.
- 스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로우(Overflow)가 발생하며, 더 이상 삭제할 데이터가 없는 삭제에서 데이터를 삭제하면 언더플로우(Underflow)가 발생한다.
- 스택의 응용 분야
  - 함수 호출의 순서 제어
  - 인터럽트의 처리
  - 수식 계산 및 수식 표기법
  - 컴파일러를 이용한 언어 번역
  - 부 프로그램 호출 시 복귀주소 저장
  - 서브루틴 호출 및 복귀주소 저장



